<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="SUMMARY.html">Index</a></li><li class="chapter-item expanded affix "><li class="part-title">Docker and Kubernetes</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Docker</li><li class="chapter-item expanded "><a href="docker/1_understanding_docker_concepts.html"><strong aria-hidden="true">1.</strong> Understanding Docker Concepts</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Basic Docker Command</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="docker/2_basic_commands.html"><strong aria-hidden="true">2.1.</strong> Basic Commands</a></li><li class="chapter-item expanded "><a href="docker/3_running_command_inside_container.html"><strong aria-hidden="true">2.2.</strong> Running command inside container</a></li><li class="chapter-item expanded "><a href="docker/4_docker_cleanup.html"><strong aria-hidden="true">2.3.</strong> Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="docker/5_dockerfile.html"><strong aria-hidden="true">3.</strong> Dockerfile</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Docker Layer</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="docker/6_understand_docker_layer.html"><strong aria-hidden="true">4.1.</strong> Understand Docker Layer</a></li><li class="chapter-item expanded "><a href="docker/7_union_file_system.html"><strong aria-hidden="true">4.2.</strong> Union File System</a></li></ol></li><li class="chapter-item expanded "><a href="docker/8_health_check.html"><strong aria-hidden="true">5.</strong> Health Check</a></li><li class="chapter-item expanded "><a href="docker/9_restart_policies.html"><strong aria-hidden="true">6.</strong> Restart Policies</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Docker Volumes</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="docker/10_docker_volume.html"><strong aria-hidden="true">7.1.</strong> Docker Volume</a></li><li class="chapter-item expanded "><a href="docker/11_mount_host_path.html"><strong aria-hidden="true">7.2.</strong> Mount host path</a></li></ol></li><li class="chapter-item expanded "><a href="docker/12_docker_network.html"><strong aria-hidden="true">8.</strong> Docker Network</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Docker Compose</li><li class="chapter-item expanded "><a href="dockercompose/1_docker_compose.html"><strong aria-hidden="true">9.</strong> Docker Compose</a></li><li class="chapter-item expanded "><a href="dockercompose/2_docker_compose_publish_ports.html"><strong aria-hidden="true">10.</strong> Publishing Ports</a></li><li class="chapter-item expanded "><a href="dockercompose/3_docker_compose_logs.html"><strong aria-hidden="true">11.</strong> Logs</a></li><li class="chapter-item expanded "><a href="dockercompose/4_docker_compose_multiple_services.html"><strong aria-hidden="true">12.</strong> Multiple Services</a></li><li class="chapter-item expanded "><a href="dockercompose/5_docker_compose_volumes.html"><strong aria-hidden="true">13.</strong> Volumes</a></li><li class="chapter-item expanded "><a href="dockercompose/6_docker_compose_network.html"><strong aria-hidden="true">14.</strong> Network</a></li><li class="chapter-item expanded "><a href="dockercompose/7_docker_compose_restart_policy.html"><strong aria-hidden="true">15.</strong> Restart Policy</a></li><li class="chapter-item expanded "><a href="dockercompose/8_docker_compose_health_check.html"><strong aria-hidden="true">16.</strong> Health Check</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Maven Docker Plugin</li><li class="chapter-item expanded "><a href="maven/1_maven_docker_plugin.html"><strong aria-hidden="true">17.</strong> Maven Docker Plugin</a></li><li class="chapter-item expanded "><a href="maven/2_maven_docker_healthcheck.html"><strong aria-hidden="true">18.</strong> Health Check</a></li><li class="chapter-item expanded "><a href="maven/3_maven_docker_multiple_container.html"><strong aria-hidden="true">19.</strong> Multiple Container</a></li><li class="chapter-item expanded "><a href="maven/4_maven_docker_volume.html"><strong aria-hidden="true">20.</strong> Volume</a></li><li class="chapter-item expanded "><a href="maven/5_maven_docker_network.html"><strong aria-hidden="true">21.</strong> Network</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Kubernetes</li><li class="chapter-item expanded "><a href="kube/1_understanding_kubernetes.html"><strong aria-hidden="true">22.</strong> Understanding Kubernetes</a></li><li class="chapter-item expanded "><a href="kube/2_pods.html"><strong aria-hidden="true">23.</strong> Pods</a></li><li class="chapter-item expanded "><a href="kube/3_resource_template.html"><strong aria-hidden="true">24.</strong> Update Resource Template</a></li><li class="chapter-item expanded "><a href="kube/4_liveness_probe.html"><strong aria-hidden="true">25.</strong> Liveness Probe</a></li><li class="chapter-item expanded "><a href="kube/5_replica_set.html"><strong aria-hidden="true">26.</strong> ReplicaSet</a></li><li class="chapter-item expanded "><a href="kube/6_service.html"><strong aria-hidden="true">27.</strong> Service</a></li><li class="chapter-item expanded "><a href="kube/7_readiness_probe.html"><strong aria-hidden="true">28.</strong> Readiness Probe</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Deployment</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="kube/8_creating_deployment.html"><strong aria-hidden="true">29.1.</strong> Creating Deployment</a></li><li class="chapter-item expanded "><a href="kube/9_rolling_update_deployment_strategy.html"><strong aria-hidden="true">29.2.</strong> Rolling Update Deployment Strategy</a></li><li class="chapter-item expanded "><a href="kube/10_rolling_back_update.html"><strong aria-hidden="true">29.3.</strong> Rolling Back Update</a></li><li class="chapter-item expanded "><a href="kube/11_failed_deployment.html"><strong aria-hidden="true">29.4.</strong> Failed Deployment</a></li><li class="chapter-item expanded "><a href="kube/11_recreate_deployment_strategy.html"><strong aria-hidden="true">29.5.</strong> Recreate Deployment Strategy</a></li><li class="chapter-item expanded "><a href="kube/12_blue_green_deployment_strategy.html"><strong aria-hidden="true">29.6.</strong> Blue Green Deployment</a></li></ol></li><li class="chapter-item expanded "><a href="kube/13_env_variable.html"><strong aria-hidden="true">30.</strong> Environment Variable</a></li><li class="chapter-item expanded "><a href="kube/14_config_maps.html"><strong aria-hidden="true">31.</strong> Config Maps</a></li><li class="chapter-item expanded "><a href="kube/15_secrets.html"><strong aria-hidden="true">32.</strong> Secrets</a></li><li class="chapter-item expanded "><a href="kube/16_host_path.html"><strong aria-hidden="true">33.</strong> Host Path</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p><a href="SUMMARY.html">Index</a></p>
<h1 id="docker-and-kubernetes"><a class="header" href="#docker-and-kubernetes">Docker and Kubernetes</a></h1>
<hr />
<h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<ul>
<li><a href="./docker/1_understanding_docker_concepts.html">Understanding Docker Concepts</a></li>
<li><a href="">Basic Docker Command</a>
<ul>
<li><a href="./docker/2_basic_commands.html">Basic Commands</a></li>
<li><a href="./docker/3_running_command_inside_container.html">Running command inside container</a></li>
<li><a href="./docker/4_docker_cleanup.html">Cleanup</a></li>
</ul>
</li>
<li><a href="./docker/5_dockerfile.html">Dockerfile</a></li>
<li><a href="">Docker Layer</a>
<ul>
<li><a href="./docker/6_understand_docker_layer.html">Understand Docker Layer</a></li>
<li><a href="./docker/7_union_file_system.html">Union File System</a></li>
</ul>
</li>
<li><a href="./docker/8_health_check.html">Health Check</a></li>
<li><a href="./docker/9_restart_policies.html">Restart Policies</a></li>
<li><a href="">Docker Volumes</a>
<ul>
<li><a href="./docker/10_docker_volume.html">Docker Volume</a></li>
<li><a href="./docker/11_mount_host_path.html">Mount host path</a></li>
</ul>
</li>
<li><a href="./docker/12_docker_network.html">Docker Network</a></li>
</ul>
<hr />
<h1 id="docker-compose"><a class="header" href="#docker-compose">Docker Compose</a></h1>
<ul>
<li><a href="./dockercompose/1_docker_compose.html">Docker Compose</a></li>
<li><a href="./dockercompose/2_docker_compose_publish_ports.html">Publishing Ports</a></li>
<li><a href="./dockercompose/3_docker_compose_logs.html">Logs</a></li>
<li><a href="./dockercompose/4_docker_compose_multiple_services.html">Multiple Services</a></li>
<li><a href="./dockercompose/5_docker_compose_volumes.html">Volumes</a></li>
<li><a href="./dockercompose/6_docker_compose_network.html">Network</a></li>
<li><a href="./dockercompose/7_docker_compose_restart_policy.html">Restart Policy</a></li>
<li><a href="./dockercompose/8_docker_compose_health_check.html">Health Check</a></li>
</ul>
<hr />
<h1 id="maven-docker-plugin"><a class="header" href="#maven-docker-plugin">Maven Docker Plugin</a></h1>
<ul>
<li><a href="./maven/1_maven_docker_plugin.html">Maven Docker Plugin</a></li>
<li><a href="./maven/2_maven_docker_healthcheck.html">Health Check</a></li>
<li><a href="./maven/3_maven_docker_multiple_container.html">Multiple Container</a></li>
<li><a href="./maven/4_maven_docker_volume.html">Volume</a></li>
<li><a href="./maven/5_maven_docker_network.html">Network</a></li>
</ul>
<hr />
<h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<ul>
<li><a href="./kube/1_understanding_kubernetes.html">Understanding Kubernetes</a></li>
<li><a href="./kube/2_pods.html">Pods</a></li>
<li><a href="./kube/3_resource_template.html">Update Resource Template</a></li>
<li><a href="./kube/4_liveness_probe.html">Liveness Probe</a></li>
<li><a href="./kube/5_replica_set.html">ReplicaSet</a></li>
<li><a href="./kube/6_service.html">Service</a></li>
<li><a href="./kube/7_readiness_probe.html">Readiness Probe</a></li>
<li><a href="">Deployment</a>
<ul>
<li><a href="./kube/8_creating_deployment.html">Creating Deployment</a></li>
<li><a href="./kube/9_rolling_update_deployment_strategy.html">Rolling Update Deployment Strategy</a></li>
<li><a href="./kube/10_rolling_back_update.html">Rolling Back Update</a></li>
<li><a href="./kube/11_failed_deployment.html">Failed Deployment</a></li>
<li><a href="./kube/11_recreate_deployment_strategy.html">Recreate Deployment Strategy</a></li>
<li><a href="./kube/12_blue_green_deployment_strategy.html">Blue Green Deployment</a></li>
</ul>
</li>
<li><a href="./kube/13_env_variable.html">Environment Variable</a></li>
<li><a href="./kube/14_config_maps.html">Config Maps</a></li>
<li><a href="./kube/15_secrets.html">Secrets</a></li>
<li><a href="./kube/16_host_path.html">Host Path</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-docker-concepts"><a class="header" href="#understanding-docker-concepts">Understanding Docker Concepts</a></h1>
<h2 id="why-docker"><a class="header" href="#why-docker">Why Docker?</a></h2>
<ul>
<li>To pack an application with all the dependencies it needs into a single, standardized unit for the deployment.</li>
<li>Packaging all of this into a complete image guarantees that it is portable.</li>
<li>It will always run in the same way, no matter what environment it is deployed in.</li>
<li>Tool that helps in solving the common problems such as installing, distributing, and managing the software.</li>
</ul>
<h2 id="docker-images"><a class="header" href="#docker-images">Docker images</a></h2>
<ul>
<li>Think of an image as a read-only template which is a base foundation for creating container.</li>
<li>Docker images are executable packages that include everything needed to run an application.</li>
<li>It includes  the code, a runtime, libraries, environment variables, and configuration files.</li>
<li>It can also include an application server like Tomcat, Netty and/or application itself.</li>
<li>Images are created using a series of commands, called instructions.</li>
<li>Instructions are placed in the Dockerfile which we will learn later.</li>
</ul>
<h2 id="docker-containers"><a class="header" href="#docker-containers">Docker Containers</a></h2>
<ul>
<li>A running instance of an image is called a container.</li>
<li>Docker containers are a runtime instance of an image.</li>
<li>What the image becomes in memory when executed.</li>
<li>It is an image with state, or a user process.</li>
</ul>
<pre><code>+-----------------------+ +-----------------------+
|       Container       | |       Container       |
|   +---------------+   | |                       |
|   |  Application  |   | |                       |
|   +---------------+   | |                       |
|   +---------------+   | |   +---------------+   |
|   |     Java      |   | |   |     MySQL     |   |
|   +---------------+   | |   +---------------+   |
|   +---------------+   | |   +---------------+   |
|   |    Alpine     |   | |   |    Ubuntu     |   |
|   +---------------+   | |   +---------------+   |
|                       | |                       |
+-----------------------+ +-----------------------+
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-commands"><a class="header" href="#basic-commands">Basic Commands</a></h1>
<hr />
<h2 id="running-container"><a class="header" href="#running-container">Running container</a></h2>
<h3 id="docker-run-image"><a class="header" href="#docker-run-image"><code>docker run @image</code></a></h3>
<ul>
<li>Let's start with simple image hello-world.</li>
<li>To run that image execute docker run hello-world.</li>
<li>Here's a output you will get</li>
</ul>
<pre><code class="language-bash">➜ docker run hello-world   
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
1b930d010525: Pull complete 
Digest: sha256:2557e3c07ed1e38f26e389462d03ed943586f744621577a99efb77324b0fe535
Status: Downloaded newer image for hello-world:latest
	
Hello from Docker!

This message shows that your installation appears to be working correctly.
...
...
</code></pre>
<ul>
<li>If you look at the output you will see that docker does few things for us.</li>
<li>It will check if the image is available locally. </li>
<li>If not, it will be pulled down from the remote repository. </li>
<li>It initializes the image's name and resources containers needs like CPU, IP, Memory etc. </li>
<li>After that it will run the container.</li>
<li>When container is started, it will execute a command.</li>
<li>Command is defined in image itself. We will talk about this later.</li>
</ul>
<h2 id="listing-local-images"><a class="header" href="#listing-local-images">Listing local images</a></h2>
<h3 id="docker-image-list"><a class="header" href="#docker-image-list"><code>docker image list</code></a></h3>
<ul>
<li>Or docker images</li>
<li>Lists the images that are available in your local system.</li>
<li>You can use any version of command you like.</li>
</ul>
<pre><code class="language-bash">➜ docker image list                 
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              fce289e99eb9        6 weeks ago         1.84kB
</code></pre>
<h2 id="listing-container"><a class="header" href="#listing-container">Listing container</a></h2>
<ul>
<li>When we ran the image with docker run it creates a container. Duh!! it is the definition of container.</li>
<li>How can you see list of your container?</li>
</ul>
<h3 id="docker-container-list"><a class="header" href="#docker-container-list"><code>docker container list</code></a></h3>
<ul>
<li>Or docker ps</li>
<li>Use any of the command above and you will see, list of running container.</li>
</ul>
<pre><code class="language-bash">➜ docker container list 
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

</code></pre>
<ul>
<li>I don't see our container here, why?</li>
<li>Because hello-world is a simple image.</li>
<li>It executes one command and exits, hence container is stopped.</li>
</ul>
<h3 id="--all"><a class="header" href="#--all"><code>--all</code></a></h3>
<ul>
<li>If you want to see container that are stopped you can use --all option.</li>
<li>docker container list --all OR docker ps --all</li>
</ul>
<pre><code class="language-bash">➜ docker container list --all
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
bb11cd638c55        hello-world         &quot;/hello&quot;            9 minutes ago       Exited (0) 9 minutes ago                       stoic_shtern

</code></pre>
<ul>
<li>Now we are able to see our container in the list.</li>
</ul>
<h2 id="override-default-image-command"><a class="header" href="#override-default-image-command">Override default image command</a></h2>
<ul>
<li>After docker run @image we can pass @command and @argument it accepts.</li>
<li>Like docker run @image @command @arguments.</li>
<li>For this we will use another simple image busybox.</li>
<li>busybox has simple unix command which we can use.</li>
</ul>
<h3 id="docker-run-busybox-sleep-5000"><a class="header" href="#docker-run-busybox-sleep-5000"><code>docker run busybox sleep 5000</code></a></h3>
<ul>
<li>docker run busybox sleep 5000</li>
<li>This will run a busybox and at the end it will execute the command sleep 5000. </li>
<li>This kind of emulates a long running process, as container will not stop unless command exits.</li>
<li>If you list the container right now (in new terminal of course), you will see status is different.</li>
<li>It is not Exited.</li>
</ul>
<pre><code class="language-bash">➜ docker container list      
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
d7acdce83ad6        busybox             &quot;sleep 5000&quot;        23 seconds ago      Up 21 seconds                           gallant_hodgkin

</code></pre>
<h2 id="stopping-running-containers"><a class="header" href="#stopping-running-containers">Stopping running containers</a></h2>
<h3 id="docker-container-stop-id--name"><a class="header" href="#docker-container-stop-id--name">docker container stop @id / @name</a></h3>
<ul>
<li>Or docker stop @id / @name</li>
<li>To stop the container you can either use name or you can use name of the container.</li>
<li>If you list the image again (don't forget --all) you will see updated status for the container.</li>
<li>If you pass space separated @id / @name to stop more than one container.</li>
</ul>
<hr />
<h2 id="running-container-in-background"><a class="header" href="#running-container-in-background">Running container in background</a></h2>
<ul>
<li>When we ran docker run busybox sleep 5000, it blocked out terminal.</li>
<li>If you don't want that to happen, we have an option to run the container in background mode.</li>
</ul>
<h3 id="-d-option"><a class="header" href="#-d-option"><code>-d option</code></a></h3>
<ul>
<li>If you pass -d option, when running the container it will run in background.</li>
<li>docker run @options @image @command @arguments</li>
<li>docker run -d busybox sleep 5000</li>
<li>If you run above command, it will echo container id and resume it's process in background.</li>
</ul>
<h2 id="start-the-stopped-container"><a class="header" href="#start-the-stopped-container">Start the stopped container</a></h2>
<h3 id="docker-start-nameid"><a class="header" href="#docker-start-nameid"><code>docker start @name/@id</code></a></h3>
<ul>
<li>It will start the existing container instead of creating new one.</li>
<li>Not recommended, as container are supposed to be disposable.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-additional-command-inside-container"><a class="header" href="#running-additional-command-inside-container">Running additional command inside container</a></h1>
<h2 id="attach-to-running-container-terminal"><a class="header" href="#attach-to-running-container-terminal">Attach to running container terminal</a></h2>
<h3 id="-it-option"><a class="header" href="#-it-option"><code>-it</code> option</a></h3>
<ul>
<li><code>-it</code> option will attach container terminal to our host</li>
<li>After that we can issue command directly to container.</li>
<li>After that every command you issue will be inside the container.</li>
<li>(Play around with some command)</li>
<li>If you want to get out of the container you can <strong>exit</strong> the terminal.</li>
<li>If default command in image is not <strong>shell</strong>, we can pass shell as <code>@argument</code>.</li>
<li><code>docker run -it busybox /bin/sh</code></li>
</ul>
<h3 id="docker-container-exec"><a class="header" href="#docker-container-exec"><code>docker container exec</code></a></h3>
<ul>
<li><code>docker container exec</code> is used to execute command inside running container.</li>
<li><code>docker container exec @id @command</code></li>
<li>But we can use same option here <code>-it</code> and pass in <strong>shell</strong> as command. (Which is default for <code>busybox</code>)</li>
<li>So <code>docker container exec -it @id</code> will attach container terminal to host.</li>
<li>If you run <code>ps aux</code> inside the container, you can see <code>sleep 5000</code> is a running process.</li>
</ul>
<pre><code class="language-bash">➜ docker container exec -it @id
/ # ps aux
PID   USER     TIME  COMMAND
    1 root      0:00 sleep 5000
    9 root      0:00 /bin/sh
   16 root      0:00 ps aux

</code></pre>
<hr />
<h2 id="attach-when-starting-stopped-container"><a class="header" href="#attach-when-starting-stopped-container">Attach when starting <code>stopped</code> container</a></h2>
<h3 id="docker-start--ia-nameid"><a class="header" href="#docker-start--ia-nameid"><code>docker start -ia @name/@id</code></a></h3>
<ul>
<li>If you want to attach the terminal, the option is bit different i.e <code>-ia</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deleting-container"><a class="header" href="#deleting-container">Deleting Container</a></h1>
<h2 id="delete-all-stopped-container"><a class="header" href="#delete-all-stopped-container">Delete all stopped container</a></h2>
<ul>
<li>To delete all stopped container, we can use above command.</li>
<li>Note: it will not delete the container that is running.</li>
</ul>
<h2 id="deleting-single-container"><a class="header" href="#deleting-single-container">Deleting single container</a></h2>
<ul>
<li>To delete the container we use <code>docker container rm @id/@name</code></li>
<li>If you were following the tutorial you might have one container still running in background. Let's stop and delete this container.</li>
</ul>
<h2 id="deleting-image"><a class="header" href="#deleting-image">Deleting Image</a></h2>
<h2 id="deleting-all-dangling-images"><a class="header" href="#deleting-all-dangling-images">Deleting all dangling images</a></h2>
<ul>
<li>To delete all dangling images we can use <code>docker image prune</code></li>
<li>This will delete all dangling images.</li>
<li>Dangling image = Images that doesn't have any containers.</li>
</ul>
<h2 id="delete-single-image"><a class="header" href="#delete-single-image">Delete single image</a></h2>
<ul>
<li>To delete an image we can run <code>docker image rm @id</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-dockerfile"><a class="header" href="#what-is-dockerfile">What is <code>Dockerfile</code></a></h1>
<ul>
<li><code>Dockerfile</code> is just a plain text file.</li>
<li>The plain text file contains series of instruction.</li>
<li>Docker will read <code>Dockerfile</code> when you start the process of building an image.</li>
<li>It executes the instruction one by one in orderly fashion.</li>
<li>At the end final read-only image is created.</li>
<li><strong>It's important to know that Docker uses images to run your code, not the</strong> <code>Dockerfile</code><strong>.</strong></li>
<li><code>Dockerfile</code> is just a convenient way to build your docker images.</li>
<li>Default file name for <code>Dockerfile</code> is <code>Dockerfile</code>.</li>
</ul>
<p> </p>
<hr />
<h2 id="building-an-image"><a class="header" href="#building-an-image">Building an image</a></h2>
<h3 id="docker-build"><a class="header" href="#docker-build"><code>docker build</code></a></h3>
<ul>
<li>Even if you have single instruction <code>FROM</code> you can build your image.</li>
<li>We can simply execute <code>docker build -f @pathToDockerfile -t @name:@tag @contextPath</code>.</li>
<li><code>@contextPath</code> is the path where you want docker build context path.</li>
<li><code>-f</code> takes the path to Dockerfile. If your file exist within the <code>docker build</code> context path and your file name is <code>Dockerfile</code> you don't need to use <code>-f</code> flag.</li>
<li><code>-t</code> represents <code>tag</code>. This is so that you can name the image you are building.</li>
<li>If you omit the <code>tag</code> part, docker will add by default <strong>latest</strong> tag.</li>
<li>Notice when it builds an image, if you don't have the image that you used locally it will download it first.</li>
</ul>
<pre><code class="language-bash">➜ docker build -f docker/web-basic -t amantuladhar/doc-kub-ws:web-basic .
Sending build context to Docker daemon  17.02MB
Step 1/1 : FROM openjdk:8-jre-alpine
8-jre-alpine: Pulling from library/openjdk
6c40cc604d8e: Pull complete 
e78b80385239: Pull complete 
f41fe1b6eee3: Pull complete 
Digest: sha256:712abc7541d52998f14b43998227eeb17fd895cf10957ad5cf195217ab62153e
Status: Downloaded newer image for openjdk:8-jre-alpine
 ---&gt; 1b46cc2ba839
Successfully built 1b46cc2ba839
Successfully tagged amantuladhar/docker-kubernetes:dockerfile-basics
</code></pre>
<ul>
<li>Run <code>docker image list</code> and you will see your image on the list</li>
<li>(Psst!! You can go inside your image an play around with it)</li>
</ul>
<h2 id="from"><a class="header" href="#from"><code>FROM</code></a></h2>
<ul>
<li><code>FROM</code> is the first instruction in <code>Dockerfile</code>.</li>
<li>Sets the base image for every subsequent instruction.</li>
<li>If you skip tag, docker will use latest tag.</li>
<li>Latest tag may not be latest image.</li>
<li>If we provide invalid tag, docker will complain.</li>
</ul>
<pre><code class="language-bash">FROM openjdk:8-jre-alpine
</code></pre>
<h2 id="workdir"><a class="header" href="#workdir">WORKDIR</a></h2>
<ul>
<li>Sets starting point from where you want to execute subsequent instructions.</li>
<li>We can set both absolute / relative path</li>
<li>We can have multiple <code>WORKDIR</code> in images</li>
<li>If relative path is used, it will be relative to previous <code>WORKDIR</code></li>
<li>Think of this as changing the directory</li>
</ul>
<pre><code class="language-bash">FROM openjdk:8-jre-alpine
WORKDIR /myApp
</code></pre>
<h2 id="copy"><a class="header" href="#copy">COPY</a></h2>
<ul>
<li><code>COPY @source @destination</code></li>
<li>Copies files from source to container file system</li>
<li>Source can be path or URL</li>
<li>Path is relative to where build process was started.</li>
<li>Both can contain wildcards like * and ?</li>
<li>Let's add our app executable inside docker image.</li>
<li>Before that you need app.</li>
<li>You can create one yourself or I have a simple <a href="https://github.com/amantuladhar/DockerKubernetesFiles/blob/master/docker/web-basic">spring app here.</a></li>
<li>For this exercise lets switch to branch <strong>dockerfile-initial</strong>.</li>
<li>Let's build <code>jar</code> for our app. <code>./mvnw clean install</code></li>
<li>Maven creates <code>jar</code> inside <strong>/target</strong> folder.</li>
</ul>
<blockquote>
<p><strong>web-basic</strong> is a Dockerfile has complete instructions.</p>
</blockquote>
<pre><code class="language-bash">FROM openjdk:8-jre-alpine
WORKDIR /myApp
COPY [&quot;onlyweb/target/*.jar&quot;, &quot;./app.jar&quot;]
</code></pre>
<ul>
<li>That's it. Build your image. Go inside an run the app</li>
</ul>
<pre><code class="language-bash">Sending build context to Docker daemon  17.03MB
Step 1/3 : FROM openjdk:8-jre-alpine
 ---&gt; 1b46cc2ba839
Step 2/3 : WORKDIR /myApp
 ---&gt; Running in 529b938e7bde
Removing intermediate container 529b938e7bde
 ---&gt; a40643187675
Step 3/3 : COPY [&quot;onlyweb/target/*.jar&quot;, &quot;./app.jar&quot;]
 ---&gt; 63722ad415fe
Successfully built 63722ad415fe
Successfully tagged amantuladhar/doc-kub-ws:web-basic
</code></pre>
<p> </p>
<hr />
<h2 id="running-your-app"><a class="header" href="#running-your-app">Running your app</a></h2>
<h3 id="docker-run--it-amantuladhardoc-kub-wsweb-basic"><a class="header" href="#docker-run--it-amantuladhardoc-kub-wsweb-basic"><code>docker run -it amantuladhar/doc-kub-ws:web-basic</code></a></h3>
<pre><code class="language-bash">➜ docker run -it amantuladhar/doc-kub-ws:web-basic
/myApp # ls
app.jar

/myApp # java -jar app.jar 

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.1.2.RELEASE)
...
...
2019-02-13 15:02:09.789  INFO 9 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
</code></pre>
<ul>
<li>You still can't access the app from outside as you haven't asked docker to export the port the app is listening to.</li>
</ul>
<h2 id="add"><a class="header" href="#add">ADD</a></h2>
<ul>
<li>ADD @source @destination</li>
<li>Exactly as COPY</li>
<li>Has few features like, archive extractions. (Like extracting achieve automatically)</li>
<li>Best practice is to use <code>COPY</code> if you don’t need those additional features.</li>
</ul>
<h2 id="expose"><a class="header" href="#expose">EXPOSE</a></h2>
<ul>
<li><code>EXPOSE @port</code></li>
<li><code>EXPOSE</code> tells Docker the running container listens on specific network ports.</li>
<li>This acts as a kind of port mapping documentation that can then be used when <strong>publishing the ports</strong>.</li>
<li><code>EXPOSE</code> will <strong>not allow</strong> communication via the defined ports to containers outside of the same network or to the host machine.</li>
<li>To allow this to happen you need to publish the ports using <code>-p</code> options when running container</li>
</ul>
<pre><code class="language-bash">FROM openjdk:8-jre-alpine
WORKDIR /myApp
EXPOSE 8080
COPY [&quot;onlyweb/target/*.jar&quot;, &quot;./app.jar&quot;]
</code></pre>
<h2 id="port-publishing"><a class="header" href="#port-publishing">Port Publishing</a></h2>
<ul>
<li>If you want to access your app from the host (outside the container), you need to publish the port where your app is expecting a connection.</li>
<li>To do that we have <code>-p @hostPort:@containerPort</code> option.</li>
<li>To access your app on <strong>localhost:9090</strong></li>
</ul>
<pre><code class="language-bash">➜ docker run -it -p 9090:8080 amantuladhar/doc-kub-ws:web-basic

# Running your app inside the container
/myApp # java -jar app.jar 
....
....
2019-02-14 04:47:05.036  INFO 10 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2019-02-14 04:47:05.046  INFO 10 --- [           main] c.e.cloudnative.CloudNativeApplication   : Started CloudNativeApplication in 4.73 seconds (JVM running for 5.685)
</code></pre>
<ul>
<li>Here's a response that we get when we call <code>localhost:9090/test</code></li>
</ul>
<pre><code class="language-bash">➜ http localhost:9090/test  
HTTP/1.1 200 
Content-Type: application/json;charset=UTF-8
Date: Thu, 14 Feb 2019 04:49:07 GMT
Transfer-Encoding: chunked

{
    &quot;app.version&quot;: &quot;v1-web&quot;,
    &quot;host.address&quot;: &quot;172.17.0.2&quot;,
    &quot;message&quot;: &quot;Hello Fellas!!!&quot;
}
</code></pre>
<h2 id="run"><a class="header" href="#run">RUN</a></h2>
<ul>
<li><code>RUN @command</code></li>
<li><code>RUN</code> is central executing instruction for <code>Dockerfile</code>.</li>
<li><code>RUN</code> command will execute a command or list of command in a new layer on top of current image</li>
<li>Resulting image will be new base image for subsequent instruction</li>
<li>To make your <code>Dockerfile</code> more readable and easier to maintain, you can split long or complex <code>RUN</code> statements on <strong>multiple lines separating them with a backslash (</strong> <code>\</code> <strong>)</strong></li>
<li>Lets install <code>curl</code> in our image. (We will need to use <code>curl</code> later)</li>
<li><code>RUN apk add --no-cache curl</code></li>
</ul>
<pre><code class="language-bash">FROM openjdk:8-jre-alpine
WORKDIR /myApp
EXPOSE 8080
RUN apk add --no-cache curl
COPY [&quot;onlyweb/target/*.jar&quot;, &quot;./app.jar&quot;]
</code></pre>
<ul>
<li>If you build your app now, you will have <code>curl</code> command when you run the container.</li>
<li>You can test if <code>curl</code> exist if you want.</li>
</ul>
<pre><code class="language-bash">➜ docker build -f docker/web-basic -t amantuladhar/doc-kub-ws:web-basic          
...
Step 4/5 : RUN apk add --no-cache curl
 ---&gt; Running in 883ac8f78866
fetch http://dl-cdn.alpinelinux.org/alpine/v3.9/main/x86_64/APKINDEX.tar.gz
fetch http://dl-cdn.alpinelinux.org/alpine/v3.9/community/x86_64/APKINDEX.tar.gz
(1/4) Installing nghttp2-libs (1.35.1-r0)
(2/4) Installing libssh2 (1.8.0-r4)
(3/4) Installing libcurl (7.63.0-r0)
(4/4) Installing curl (7.63.0-r0)
...
</code></pre>
<h2 id="entrypoint"><a class="header" href="#entrypoint">ENTRYPOINT</a></h2>
<ul>
<li>The <code>ENTRYPOINT</code> specifies a command that will always be executed when the container starts.</li>
<li>Docker has a default <code>ENTRYPOINT</code> which is <code>/bin/sh -c</code></li>
<li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> is the exec form, preferred and recommended.</li>
<li><code>ENTRYPOINT command param1 parm2</code> is a shell form.</li>
<li><code>ENTRYPOINT</code> is the runtime instruction, but <code>RUN</code>, <code>ADD</code> are build time instructions.</li>
<li>We can use <code>--entrypoint</code> option to override when you run the container.</li>
</ul>
<pre><code class="language-bash">FROM openjdk:8-jre-alpine
WORKDIR /myApp
EXPOSE 8080
RUN apk add --no-cache curl
COPY [&quot;onlyweb/target/*.jar&quot;, &quot;./app.jar&quot;]
ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]
</code></pre>
<ul>
<li>Build the image and run the image, without <code>-it</code> option.</li>
<li><code>docker run -p 9090:8080 amantuladhar/doc-kub-ws:web-basic</code></li>
<li>You app will run, you didn't needed to go inside the container and execute the command yourself.</li>
<li><code>-p 9090:8080</code> was added so that you can access your app from host.</li>
</ul>
<h2 id="cmd"><a class="header" href="#cmd">CMD</a></h2>
<ul>
<li><code>CMD</code> also specifies a command that will execute when container starts.</li>
<li>The <code>CMD</code> specifies the arguments that will be fed to the <code>ENTRYPOINT</code>.</li>
<li><code>CMD [&quot;executable&quot;,&quot;parameter1&quot;,&quot;parameter2&quot;]</code> this is a so called exec form. (Preferred)</li>
<li><code>CMD command parameter1 parameter2</code> this a shell form of the instruction.</li>
<li>Like <code>ENTRYPOINT</code> <code>CMD</code> is a runtime instruction as well.</li>
<li>You already know how to override the <code>CMD</code>, just pass it after the image name when you run the container.</li>
</ul>
<pre><code class="language-bash">FROM openjdk:8-jre-alpine
WORKDIR /myApp
EXPOSE 8080
RUN apk add --no-cache curl
COPY [&quot;onlyweb/target/*.jar&quot;, &quot;./app.jar&quot;]
ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;]
CMD [&quot;app.jar&quot;]
</code></pre>
<ul>
<li>As you can see, <code>ENTRYPOINT</code> defines the command that gets executed when container starts.</li>
<li><code>CMD</code> is passing argument to <code>ENTRYPOINT</code>.</li>
<li>Build and run the app. <code>docker run -p 9090:8080 amantuladhar/doc-kub-ws:web-basic</code>.</li>
</ul>
<h2 id="overriding-cmd"><a class="header" href="#overriding-cmd"><strong>Overriding CMD</strong></a></h2>
<ul>
<li><code>docker run @image@command @arguments</code>.</li>
<li><code>docker run -p 9090:8080 amantuladhar/doc-kub-ws:web-basic test.jar</code>.</li>
<li>Of course above command won't run because we don't have <code>test.jar</code> in our image.</li>
</ul>
<pre><code class="language-bash">➜ docker run -p 9090:8080 amantuladhar/doc-kub-ws:web-basic test.jar
Error: Unable to access jarfile test.jar
</code></pre>
<ul>
<li>How about we try to attach container terminal to host terminal using <code>-it</code></li>
<li><code>docker run -it amantuladhar/doc-kub-ws:web-basic</code> won't work as this will run the app.</li>
<li><code>docker run -it amantuladhar/doc-kub-ws:web-basic sh</code> won't work as it internally run <code>java -jar sh</code>.</li>
<li>If you really want to attach container terminal to host terminal you need to override the <code>ENTRYPOINT</code>.</li>
<li><code>docker run --entrypoint sh -it amantuladhar/doc-kub-ws:web-basic</code></li>
</ul>
<pre><code class="language-bash">➜ docker run --entrypoint sh  -it amantuladhar/doc-kub-ws:web-basic        
/myApp #
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understand-docker-layer"><a class="header" href="#understand-docker-layer">Understand Docker Layer</a></h1>
<p> </p>
<hr />
<h2 id="docker-layers"><a class="header" href="#docker-layers">Docker layers?</a></h2>
<ul>
<li>Layer is basically a change on an image, or an intermediate image. </li>
<li>Every instructions you specify (FROM, RUN, COPY, etc.) in your Dockerfile causes the previous image to change, thus creating a new layer. </li>
<li>That image layer then becomes the parent for the layer created by the next instruction.</li>
<li>Final image  and/or image that we use consists of a series of layers which are stacked, one on top of the another.</li>
<li>You can think of it as staging changes when you're using git. You add a file's change, then another one, then another one.</li>
<li>When you build your image before, you also created lots of images.</li>
<li><code>docker build . -t docker-kubernetes:dockerfile-basics</code></li>
</ul>
<pre><code class="language-bash">                            +---------------------------------+
             +------------&gt; |          6e384ad670e7           |
             |              | CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;] |
             |              +---------------------------------+
             +------------&gt; |          adfedcd08e78           |
             |              |COPY [&quot;target/*.jar&quot;, &quot;./app.jar&quot;|
             |              +---------------------------------+
             +------------&gt; |          aae885b8525e           |
Layer Id+----+              |   RUN apk add --no-cache curl   |
             |              +---------------------------------+
             +------------&gt; |          14446213dae8           |
             |              |           EXPOSE 8080           |
             |              +---------------------------------+
             +------------&gt; |          a40643187675           |
             |              |          WORKDIR /myApp         |
             |              +---------------------------------+
             +------------&gt; |          1b46cc2ba839           |
                            |    FROM openjdk:8-jre-alpine    |
                            +---------------------------------+
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="union-file-system"><a class="header" href="#union-file-system">Union File System</a></h1>
<p> </p>
<hr />
<h2 id="how-union-filesystem-works"><a class="header" href="#how-union-filesystem-works">How Union Filesystem works?</a></h2>
<ul>
<li>By using the union filesystem, Docker combines all these layers into a single image entity.</li>
<li>Filesystem structure of the top layer will merge with the structure of the layer beneath. </li>
<li>Files and directories which have the same path as in the previous layer will override those beneath.</li>
</ul>
<pre><code class="language-bash">        +-----------------+
        |    FILE_4.txt   |----+
        +-----------------+    |
                               |       +---------------+
                               |       |               |
        +-----------------+    |       |  FILE_1.txt   |
        |    FILE_2.txt   |---------&gt;  |  FILE_2.txt   |
        |    FILE_3.txt   |    |       |  FILE_3.txt   |
        +-----------------+    |       |  FILE_4.txt   |
                               |       |               |
                               |       +---------------+
        +-----------------+    |
        |    FILE_1.txt   |----+
        |    FILE_2.txt   |
        +-----------------+
</code></pre>
<p> </p>
<hr />
<h2 id="how-are-layers-connected"><a class="header" href="#how-are-layers-connected">How are layers connected?</a></h2>
<ul>
<li>To maintain the order of layers, Docker utilizes the concept of layer IDs and pointers.</li>
<li>Each layer contains the ID and a pointer to its parent layer. </li>
<li>A layer without a pointer referencing the parent is the first layer in the stack, a base.</li>
<li>Layers are reusable and cacheable. If same kind of layers are found, docker will reuse it.</li>
<li>Reusable layers is also a reason why Docker is so lightweight in comparison to full virtual machines, which don't share anything. It is thanks to layers that when you pull an image, you eventually don't have to download all of its filesystem</li>
</ul>
<pre><code class="language-bash">            +---------------------------+
            |         Layer Id          |
            |                           |
            |         Parent Id         |
            +------------|--------------+
                         |
            +------------v--------------+
            |         Layer id          |
            |                           |
            |         Parent Id         |
            +------------|--------------+
                         |
            +------------v--------------+
            |         Layer id          |
            |                           |
            |         Parent Id         |
            +------------+--------------+
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="health-check"><a class="header" href="#health-check">Health Check</a></h1>
<p> </p>
<hr />
<h2 id="what-is-healthcheck"><a class="header" href="#what-is-healthcheck">What is HEALTHCHECK</a></h2>
<ul>
<li>The HEALTHCHECK instruction tells Docker how to test a container to check that it is still working. </li>
<li>There could be a scenario where our application process is still running, but may not respond to our request.</li>
<li>HEALTHCHECK instruction helps us to identify this issue.</li>
<li>We can have multiple HEALTHCHECK instruction in our Dockerfile but only last one will take an effect.</li>
<li>When a container has a HEALTHCHECK specified, it has a health status in addition to its normal status. </li>
</ul>
<blockquote>
<p>Note: Kubernetes doesn't support this HEALTHCHECK instruction. Kubernetes has its own way to checking if containers are healthy.</p>
</blockquote>
<h2 id="healthcheck"><a class="header" href="#healthcheck">HEALTHCHECK</a></h2>
<ul>
<li>The HEALTHCHECK instruction can be used in two forms.
<ul>
<li>HEALTHCHECK [OPTIONS] CMD command. Which checks container health by running a command inside the container.</li>
<li>HEALTHCHECK NONE. This will disable any health check inherited from the base image.</li>
</ul>
</li>
<li>If you are using the app from Simple Spring App, make sure you are in dockerfile-initial branch.</li>
<li>We have couple of REST endpoints in the app
<ul>
<li><code>/test/</code> which kind of hello-world endpoint for us </li>
<li><code>/test/status-5xx</code> which will return status 200 for first 5 times, but after that it will throw exception. Our app will still be running.</li>
<li><code>/test/exit-1</code> to exit the app with non-zero status code.</li>
<li><code>/test/exit-0</code> to exit the app with zero status code.</li>
</ul>
</li>
<li>Let's add HEALTHCHECK in our image.</li>
<li><code>HEALTHCHECK CMD curl --fail http://localhost:8080/test || exit 1</code></li>
<li>We are making a curl request to our app and if it fails we are exiting our app with status code 1.</li>
</ul>
<pre><code class="language-bash">FROM openjdk:8-jre-alpine
WORKDIR /myApp
EXPOSE 8080
RUN apk add --no-cache curl
COPY [&quot;onlyweb/target/*.jar&quot;, &quot;./app.jar&quot;]
CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]
HEALTHCHECK CMD curl --fail http://localhost:8080/test || exit 1
</code></pre>
<ul>
<li>Let's build and run this image.</li>
</ul>
<pre><code class="language-bash">IMAGE                                 STATUS                    
amantuladhar/doc-kub-ws:web-basic     Up XX seconds (healthy)
</code></pre>
<ul>
<li>We will play around with HEALTHCHECK more, but first let's learn about different options HEALTHCHECK supports. </li>
</ul>
<h2 id="--interval"><a class="header" href="#--interval">--interval</a></h2>
<ul>
<li>--interval=@duration</li>
<li>Default duration time is 30s</li>
<li>This configures time HEALTHCHECK needs to wait before it runs next HEALTHCHECK CMD.</li>
</ul>
<h2 id="--timeout"><a class="header" href="#--timeout">--timeout</a></h2>
<ul>
<li>--timeout=@duration</li>
<li>Default timeout is 30s</li>
<li>This configures the time it should take a HEALTHCHECK CMD to finish.</li>
<li>If a single CMD run takes longer than timeout seconds then the check is considered to have failed.</li>
</ul>
<h2 id="--retries"><a class="header" href="#--retries">--retries</a></h2>
<ul>
<li>--retries=@numberOfRetries</li>
<li>Default value for retry is 3.</li>
<li>This configures how many times HEALTHCHECK needs to fail before it determines out container is unhealthy.</li>
</ul>
<h2 id="--start-period"><a class="header" href="#--start-period">--start-period</a></h2>
<ul>
<li>--start-period=@duration</li>
<li>Default value for start period duration is 0s.</li>
<li>With is option we can configure time it will take for app to run.</li>
<li>If we run pre-mature HEALTHCHECK our app might not have initialized and it may result in our container be in unhealthy state.</li>
<li>Basically it will run our first HEALTHCHECK CMD after time specified.</li>
</ul>
<p> </p>
<hr />
<h2 id="playing-with-healthcheck"><a class="header" href="#playing-with-healthcheck">Playing with HEALTHCHECK</a></h2>
<ul>
<li>Let's update our HEALTHCHECK instruction.</li>
</ul>
<pre><code class="language-bash">FROM openjdk:8-jre-alpine
WORKDIR myapp/
COPY [&quot;onlyweb/target/*.jar&quot;, &quot;app.jar&quot;]
EXPOSE 8080
RUN apk add --no-cache curl
CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]
HEALTHCHECK  --start-period=10s \
             --interval=5s \
             --timeout=2s  \
             --retries=3 \
             CMD curl --fail http://localhost:8080/test/status-5xx || exit 1
</code></pre>
<ul>
<li>Build you image and run it. And keep an eye on health status.</li>
<li>Remember status-5xx will return status 200 for first 5 calls</li>
<li>So for a minute or so our container health will be healthy.</li>
<li>But because the HEALTHCHECK is called frequently, and for our app at exactly 6th call it will start to fail.</li>
<li>On a 6th call it won't flag our container as unhealthy as we defined retries.</li>
<li>Docker makes sure that three consecutive failure happens before it flags the container as unhealthy.</li>
</ul>
<pre><code class="language-bash">IMAGE                                  CREATED             STATUS                          
amantuladhar/doc-kub-ws:web-basic      10 seconds ago      Up 10 seconds (health: starting)
</code></pre>
<pre><code class="language-bash">IMAGE                                 CREATED             STATUS                 
amantuladhar/doc-kub-ws:web-basic     24 seconds ago      Up 24 seconds (healthy)
</code></pre>
<pre><code class="language-bash">IMAGE                                 CREATED             STATUS                  
amantuladhar/doc-kub-ws:web-basic     2 minutes ago       Up 2 minutes (unhealthy)
</code></pre>
<blockquote>
<p>Complete dockerfile for with health check web-healthcheck <a href="https://github.com/amantuladhar/DockerKubernetesFiles/blob/master/docker/web-healthcheck">web-healthcheck</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="restart-policies"><a class="header" href="#restart-policies">Restart Policies</a></h1>
<p> </p>
<hr />
<ul>
<li>Restart policies is used to control whether the containers starts automatically when they exit, or even when Docker restarts.</li>
<li>Restart policies tells Docker how to react when a container shuts down.</li>
<li>A restart policy only takes effect after a container <strong>starts successfully</strong>.</li>
<li>Starting successfully means that the container is <strong>up for at least 10 seconds</strong> and Docker has started monitoring it.</li>
<li>This prevents a container which does not start at all from going into a restart loop.</li>
<li>By using the <code>--restart</code> option with the docker run command you can specify a restart policy.</li>
<li>Types of restart policies
<ul>
<li><code>no</code></li>
<li><code>always</code></li>
<li><code>no-failure</code></li>
<li><code>unless-stopped</code></li>
</ul>
</li>
</ul>
<h2 id="no"><a class="header" href="#no"><code>no</code></a></h2>
<ul>
<li>The no policy is the default restart policy and simply will not restart a container under any case.</li>
</ul>
<h2 id="always"><a class="header" href="#always"><code>always</code></a></h2>
<ul>
<li>If we wanted the container to be restarted no matter what exit code the command has, we can use the <code>always</code> restart policy.</li>
<li>The restart policy will always restart the container.</li>
<li>Whenever the Docker service is restarted, containers using the always policy will also be restarted.</li>
</ul>
<h2 id="on-failure"><a class="header" href="#on-failure"><code>on-failure</code></a></h2>
<ul>
<li>Restart your container whenever it exits with a non-zero exit status and not restart otherwise.</li>
<li>You can optionally provide a number of times for Docker to attempt to restart the container.</li>
<li><code>--restart=on-failure:@number</code></li>
<li>Docker uses a delay between restarting the container, to prevent flood-like protection.</li>
<li>This is an increasing delay; it starts with the value of 100 milliseconds, then Docker will double the previous delay.</li>
<li>If a container is successfully restarted, the delay is reset to the default value of 100 milliseconds</li>
</ul>
<h2 id="unless-stopped"><a class="header" href="#unless-stopped"><code>unless-stopped</code></a></h2>
<ul>
<li>Again, similar to always, if we want the container to be restarted regardless of the exit code, we can use <code>unless-stopped.</code></li>
<li>It will restart the container regardless of the exit status, but do not start it on daemon startup if the container has been put to a stopped state before.</li>
<li>If you are using the app from <a href="https://github.com/amantuladhar/DockerKubernetesFiles/tree/dockerfile-initial">Simple Spring App</a>, make sure you are in <code>dockerfile-initial</code> branch.</li>
<li>We have couple of REST endpoints in the app
<ul>
<li><code>/test/</code> which kind of hello-world endpoint for us</li>
<li><code>/test/status-5xx</code> which will return status 200 for first 5 times, but after that it will throw exception. Our app will still be running.</li>
<li><code>/test/exit-1</code> to exit the app with non-zero status code.</li>
<li><code>/test/exit-0</code> to exit the app with zero status code.</li>
</ul>
</li>
</ul>
<h2 id="restart-policies-in-action"><a class="header" href="#restart-policies-in-action">Restart Policies in Action</a></h2>
<ul>
<li>Let's start our app using <code>on-failure</code></li>
<li>Here's a <a href="https://github.com/amantuladhar/DockerKubernetesFiles/blob/master/docker/web-basic">Dockerfile</a> content</li>
<li>Run the image with <code>--restart</code> option.</li>
</ul>
<pre><code class="language-bash">docker run -d -p 9090:8080 --restart\=on-failure amantuladhar/doc-kub-ws:web-basic
</code></pre>
<pre><code class="language-bash">IMAGE                                 STATUS              
amantuladhar/doc-kub-ws:web-basic     Up About a minute
</code></pre>
<ul>
<li>Let's call <code>/test/exit-1</code>, which will end the process with non zero exit code.</li>
</ul>
<pre><code class="language-bash">IMAGE                                 STATUS                     
amantuladhar/doc-kub-ws:web-basic     Restarting (1) 1 second ago
</code></pre>
<ul>
<li>Now let's call <code>/test/exit-0</code>, which will end the process with zero exit code.</li>
<li>If you list the running container, you won't see it now.</li>
</ul>
<h2 id="update-restart-policies-of-running-container"><a class="header" href="#update-restart-policies-of-running-container">Update restart policies of running container</a></h2>
<ul>
<li><code>docker update --restart=new-policies @id/@name</code></li>
<li>Where <code>@id/@name</code> is of container</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-volume"><a class="header" href="#docker-volume">Docker Volume</a></h1>
<p> </p>
<hr />
<ul>
<li>Volumes are directories (or files) that are outside of the default Union File System and exist as normal directories and files on the host filesystem.</li>
</ul>
<h2 id="why-do-we-need-volume"><a class="header" href="#why-do-we-need-volume">Why do we need volume?</a></h2>
<ul>
<li>
<p>To understand why we need volumes lets go back to simple image <code>busybox</code>.</p>
</li>
<li>
<p><code>docker run -it busybox</code></p>
<ul>
<li>Create a directory and add a file. <code>touch test.txt</code></li>
<li>Run new container with same image, list the files and you won't see the file you created.</li>
<li>Why not run same container? If we run same container we will still see that file.</li>
<li>Remember container are ephemeral and disposable.</li>
<li>We should not depend on starting same container.</li>
</ul>
</li>
<li>
<p>How do we persist changes, so that when we run new container we see that file?</p>
</li>
</ul>
<h2 id="named-volume"><a class="header" href="#named-volume">Named Volume</a></h2>
<ul>
<li>The most direct way is declare a volume at run-time with the <code>-v @name:@path</code> flag.</li>
<li><code>@name</code> is name of the volume.</li>
<li><code>@path</code> is the path inside container.</li>
</ul>
<h2 id="-v-namepath"><a class="header" href="#-v-namepath"><code>-v @name:@path</code></a></h2>
<pre><code class="language-bash">docker run -v myVolume:/my-volume --it busybox
</code></pre>
<ul>
<li>This will make the directory <code>/my-volume</code> inside the container live outside the UFS and directly accessible on the host.</li>
<li>Any files that the image held inside the <code>/my-volume</code> directory will be copied into the volume.</li>
<li>If the container path specified doesn't exist docker will create one for you.</li>
</ul>
<h2 id="where-can-i-find-the-file-in-host-system"><a class="header" href="#where-can-i-find-the-file-in-host-system">Where can I find the file in host system?</a></h2>
<ul>
<li>We can see where docker is storing our file by inspecting the container.</li>
<li><code>docker inspect @container_id</code></li>
<li>If you see <strong>&quot;Mounts&quot;</strong> property, you will see properties like
<ul>
<li><strong>&quot;Source&quot;</strong> is path in the host</li>
<li><strong>&quot;Destination&quot;</strong> is path in the container</li>
</ul>
</li>
<li>If you try to navigate to path specified by <strong>&quot;Source&quot;</strong> in you computer, you won't find it. Why?</li>
<li>For docker that host path is inside Virtual Machine.</li>
<li>We can also see <code>docker volume list</code> to list all volumes.</li>
<li>As you can see volume name is big hash at the moment</li>
</ul>
<h2 id="manually-create-a-named-volume"><a class="header" href="#manually-create-a-named-volume">Manually create a named volume</a></h2>
<ul>
<li>To manually create a named volume, you can use <code>docker volume create</code> command.</li>
</ul>
<pre><code class="language-bash">docker volume create --name @volume\_name
</code></pre>
<h2 id="reattaching-same-volume"><a class="header" href="#reattaching-same-volume">Reattaching same volume</a></h2>
<ul>
<li>If you attach a same volume when running new container, you will find all previous files.</li>
</ul>
<pre><code class="language-bash">docker run -v myVolume:/my-volume -it busybox

# Create a file inside my-volume directory
&gt; touch my-volume/test.txt

# List content of my-volume directory
&gt; ls my-volume/
test.txt
</code></pre>
<ul>
<li>Running new container with same volume</li>
</ul>
<pre><code class="language-bash">docker run -v myVolume:/my-volume -it busybox
# List content of my-volume directory
&gt; ls my-volume/
test.txt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mount-host-path"><a class="header" href="#mount-host-path">Mount host path</a></h1>
<p> </p>
<hr />
<ul>
<li><code>-v</code> has yet another major use case, which can only be accomplished through <code>-v</code> option.</li>
<li>Mount the host directory into container.</li>
<li><code>docker run -v @host_path:@container_path -it busybox</code>
<ul>
<li>host path must be absolute.</li>
<li>container path is absolute as well.</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">docker run -v $(pwd)/volume/:/my-volume -it busybox
</code></pre>
<ul>
<li>We can use <code>$(pwd)</code> to get absolute path for current directory.</li>
<li>With above command, we are mounting <code>/volume</code> directory that relative to where build process was started.</li>
</ul>
<h2 id="simple-example"><a class="header" href="#simple-example">Simple example</a></h2>
<ul>
<li>Let's try this with <code>busybox</code> first.</li>
<li><code>docker run -v $(pwd)/volume/:/my-volume -it busybox</code></li>
<li>Create a file under <code>/my-volume</code> inside the container.</li>
<li>You will see that file in host directory as well, under <code>&quot;CURRENT_DIR&quot;/volume</code>.</li>
</ul>
<h2 id="using-volume-for-persistence-storage"><a class="header" href="#using-volume-for-persistence-storage">Using volume for persistence storage</a></h2>
<ul>
<li>Using volume on these case doesn't make sense.</li>
<li>We are creating a file and checking if it exists in subsequent runs.</li>
<li>But consider this scenario when you run <code>mysql</code> image.</li>
<li>You would want to persist the data that you created inside container.</li>
<li>It doesn't matter how many times you restart your container, we must not lose the data.</li>
</ul>
<h2 id="using-to-persist-mysql-data"><a class="header" href="#using-to-persist-mysql-data"><strong>Using to persist</strong> <strong><code>mysql</code></strong> <strong>data</strong></a></h2>
<ul>
<li><code>mysql</code> stores its data inside <code>/var/lib/mysql/</code>.</li>
<li>So if we map our host path with <code>/var/lib/mysql/</code>, we will be able to persist <code>mysql</code> data.</li>
<li>If you try to run the <code>mysql</code> image it expects couple of <strong>Environment Variable</strong>.
<ul>
<li><strong>MYSQL_ROOT_PASSWORD</strong></li>
<li><strong>MYSQL_DATABASE</strong></li>
</ul>
</li>
</ul>
<pre><code class="language-bash">docker run \
       -v $(pwd)/volume/mysql-data:/var/lib/mysql/ \
       -e MYSQL_ROOT_PASSWORD=test \
       -e MYSQL_DATABASE=test \
       mysql:5.7
</code></pre>
<blockquote>
<p>I am using <code>-e</code> options to pass in <strong>Environment Variables</strong> to container.</p>
</blockquote>
<ul>
<li>I am deliberately not passing <code>-it</code> when running container.</li>
<li>Default <code>CMD</code> for <code>mysql</code> image is used for starting mysql</li>
<li>If we override it my passing <strong>Shell</strong> executable, to attach the pseudo tty, it won't start the mysql.</li>
<li>After container is running, we can attach container tty into host terminal.</li>
<li>You already learned this but in case you forgot. To attach the pseudo tty for a running container we use <code>docker container exec -it @container(id/name) sh</code></li>
</ul>
<pre><code class="language-bash">docker container exec -it 750d0ddbbe51 sh
</code></pre>
<ul>
<li>Login to <code>mysql</code> from container terminal.</li>
<li>Create a table and insert some data into that table.</li>
</ul>
<pre><code class="language-bash">&gt; mysql -u root -p

mysql&gt; USE test;
Database changed

mysql&gt; CREATE TABLE student(id INT(11), name VARCHAR(255));
Query OK, 0 rows affected (0.02 sec)

mysql&gt; INSERT INTO student VALUES (1, 'Aman');
Query OK, 1 row affected (0.01 sec)

mysql&gt; SELECT * FROM student;
+------+------+
| id   | name |
+------+------+
|    1 | Aman |
+------+------+
1 row in set (0.00 sec)
</code></pre>
<ul>
<li>Now you stop the running container and run a new one, with same path (<code>$(pwd)/volume/mysql-data</code>) mapped to <code>/var/lib/mysql/</code></li>
<li>You will see data is still present.</li>
</ul>
<pre><code class="language-bash">docker run \
     -v $(pwd)/volume/mysql-data:/var/lib/mysql/ \
     -e MYSQL_ROOT_PASSWORD=test \
     -e MYSQL_DATABASE=test \
     mysql:5.7
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-network"><a class="header" href="#docker-network">Docker Network</a></h1>
<hr />
<h2 id="why-do-we-need-network"><a class="header" href="#why-do-we-need-network">Why do we need network?</a></h2>
<ul>
<li>To see why we need inter network communication, let's run two container (in background).</li>
</ul>
<pre><code class="language-bash">➜ docker run \
         -p 9090:8080
         -d amantuladhar/doc-kub-ws:web-basic
</code></pre>
<ul>
<li>Let's try to access our app from different container</li>
</ul>
<pre><code class="language-bash">➜ docker run \
         -it amantuladhar/network-tools sh
</code></pre>
<blockquote>
<p><code>network-tools</code> image have few tools like <code>curl</code>, <code>http</code>, <code>ping</code>, <code>nc</code>.</p>
</blockquote>
<ul>
<li>From this container, let's call <code>http localhost:8080/test</code>.</li>
<li>It won't work because there is no connection between those two containers.</li>
<li>Consider scenario where our app needs to talk with container that is running <strong>mysql</strong>.</li>
</ul>
<h2 id="listing-network"><a class="header" href="#listing-network"><strong>Listing network</strong></a></h2>
<pre><code class="language-bash">docker network list
</code></pre>
<ul>
<li>If you do <code>docker network list</code>, you will see three networks is already created
<ul>
<li>bridge</li>
<li>host</li>
<li>none</li>
</ul>
</li>
<li>These are networks created by different network drivers docker supports. (We have few more drivers).</li>
<li>Default driver for network is <code>bridge</code>.</li>
</ul>
<h2 id="create-a-network"><a class="header" href="#create-a-network">Create a network</a></h2>
<ul>
<li>To create a network you just issue <code>docker network create @name</code>.</li>
</ul>
<pre><code class="language-bash">docker network create myNet
</code></pre>
<ul>
<li>This will create network with name <code>myNet</code> with driver <code>bridge</code>.</li>
</ul>
<p> </p>
<hr />
<h1 id="using-network"><a class="header" href="#using-network">Using network</a></h1>
<h2 id="define-which-network-to-connect-to"><a class="header" href="#define-which-network-to-connect-to">Define which network to connect to</a></h2>
<ul>
<li><code>--net=@network_name</code> syntax.</li>
<li>To use the network we created we can use <code>--net</code> option.</li>
</ul>
<pre><code class="language-bash">➜ docker run \
         --name=myApp
         --net=myNet
         -p 9090:8080
         -d amantuladhar/doc-kub-ws:web-basic
</code></pre>
<ul>
<li>Notice I am naming my container myself using <code>--name</code> option. You will know in a bit why I am doing this.</li>
<li>This will run our container in our network <code>myNet</code>.</li>
<li>Now lets run <code>network-tools</code> image on same network.</li>
</ul>
<pre><code class="language-bash">➜ docker run \
         --name=myTester \
         --net=myNet
         -it amantuladhar/network-tools sh
</code></pre>
<ul>
<li>Try to execute <code>curl</code> on <code>localhost:8080/test</code>. or <code>localhost:9090/test</code></li>
<li>It won't work. Why? We explicitly ran both of your container on same network.</li>
</ul>
<h2 id="container-discovery"><a class="header" href="#container-discovery">Container Discovery</a></h2>
<ul>
<li>To access the app running on same network, we cannot use localhost.</li>
<li>I think this is obvious. From the application standpoint they are not running on same computer*.</li>
<li>If we can't use <strong>localhost</strong> what do we use?</li>
<li>Turns out we have to use <strong>container name</strong> i.e <code>myApp</code> in our case.</li>
<li>If you do <code>curl</code> on <code>myApp:8080/test</code> it will work.</li>
</ul>
<blockquote>
<p>Docker has builtin DNS server that converts container name to its IP.</p>
</blockquote>
<h2 id="auto-connect-to-specified-container-network"><a class="header" href="#auto-connect-to-specified-container-network">Auto connect to specified container network</a></h2>
<ul>
<li><code>--net</code> has a syntax that supports auto network discovery i.e <code>--net=container:name</code>.</li>
<li>If you use this syntax, docker will automatically connect network that is used by specified container.</li>
<li>If you use this syntax, you will be able to use <code>localhost</code> instead of <code>container_name</code> .</li>
<li>Run the image that has our app like before.</li>
</ul>
<pre><code class="language-bash">➜ docker run \
         --name=myApp
         --net=myNet
         -p 9090:8080
         -d amantuladhar/doc-kub-ws:web-basic
</code></pre>
<ul>
<li>Run the tester again with <code>container</code> syntax.</li>
</ul>
<pre><code class="language-bash">docker run \
     --name=myTester \
     --net=container:myApp \
     -it \
     amantuladhar/network-tools \
     sh 
</code></pre>
<ul>
<li>Test using localhost, and it just works.</li>
</ul>
<pre><code class="language-bash">/ # curl localhost:8080/test | jq .
{
  &quot;message&quot;: &quot;Hello Fellas!!!&quot;,
  &quot;host.address&quot;: &quot;172.23.0.3&quot;,
  &quot;app.version&quot;: &quot;v1-web&quot;
}
</code></pre>
<blockquote>
<ul>
<li>As exercise, you can try to create application that stores some values in database.</li>
<li>You can use <code>amantuladhar/docker-kubernetes:v1-db</code> image.</li>
<li>Simple Web App at branch <a href="https://github.com/amantuladhar/DockerKubernetesFiles/tree/initial-db">initial-db</a></li>
<li>App expects that you will set <code>DB_URL</code>, <code>DB_USER</code> and <code>DB_PASS</code> environment variable, which is a full connection URL for mysql.</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-compose-1"><a class="header" href="#docker-compose-1">Docker Compose</a></h1>
<hr />
<h2 id="what-is-docker-compose"><a class="header" href="#what-is-docker-compose">What is docker compose?</a></h2>
<ul>
<li><code>docker compose</code> is tool for defining and running complex applications with Docker.</li>
<li>With Compose, we define a <strong>multi-container application</strong> in a single file.</li>
<li>It allows you to spin your application up in a single command.</li>
<li>Orchestration between two containers are easy with docker compose.</li>
<li>Default file name for docker-compose is is <code>docker-compose.yml</code>.</li>
</ul>
<blockquote>
<p>Docker Compose works in the scope of a single host, where Kubernetes works on multi cluster environment.</p>
</blockquote>
<h2 id="simple-compose-file"><a class="header" href="#simple-compose-file">Simple compose file</a></h2>
<ul>
<li>This is what a simple compose file looks like.</li>
</ul>
<pre><code class="language-yaml">version: '3'                                       # 1    
services:                                          # 2
  myApp:                                             # 3
    image: amantuladhar/docker-kubernetes:v1-web     # 4 
</code></pre>
<ul>
<li><code>#1</code> specifies what version of compose API you want to use.</li>
<li><code>#2</code> is a root property. It includes list of all services (containers) compose will manage.</li>
<li><code>#3</code> is name of the service (container)</li>
<li><code>#4</code> specifies image you want to run.</li>
</ul>
<blockquote>
<p>If you want to build you app yourself you can find the app in <a href="https://github.com/amantuladhar/DockerKubernetesFiles/tree/compose-initial">Spring Simple Web</a> branch <code>compose-initial</code>.</p>
</blockquote>
<ul>
<li>You noticed that in compose file containers are called <strong>services</strong>.</li>
<li>Compose can manage multiple services, but for now we are dealing with only one.</li>
<li>We defined the service called <code>myApp</code> which will run the image.</li>
</ul>
<h2 id="build-your-image"><a class="header" href="#build-your-image">Build your image</a></h2>
<ul>
<li>If you want to build your own image instead of using one, you can do that easily too</li>
</ul>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
    build:                     # 1  
      context: .               # 2
      dockerfile: Dockerfile   # 3
</code></pre>
<ul>
<li><code>#1</code> build tag will let compose know that you want to build your image.</li>
<li><code>#2</code> context defines where your docker file are stored.</li>
<li><code>#3</code> Dockerfile takes the file name for <code>Dockerfile</code>. If the file name is <code>Dockerfile</code> you don't seed to specify the property.</li>
<li>You use <code>docker-compose build</code> to build your image. (docker compose build in the latest version)</li>
<li>If you make any changes to <code>Dockerfile</code> you need to explicitly build the image again.</li>
</ul>
<blockquote>
<p>Any docker compose command can now be used without <code>-</code> i.e as part of docker command </p>
</blockquote>
<h2 id="running-services"><a class="header" href="#running-services">Running services</a></h2>
<ul>
<li>To run the services defined in compose file is super easy.</li>
<li>You run any number of services defined inside compose file with single command.</li>
<li>i.e <code>docker-compose up</code>. On latest docker for desktop installation you can just <code>docker compose up</code>.</li>
<li>If you want to run it in background add <code>-d</code> option.</li>
<li>If you run the app right now, it will run but it won't be accessible from our host yet.</li>
<li>We need to publish ports first in order to access the app.</li>
</ul>
<h2 id="stopping-services"><a class="header" href="#stopping-services">Stopping services</a></h2>
<ul>
<li>Starting the services were easy. How about stopping them?</li>
<li>It is super easy as well. <code>docker-compose stop</code>. (<code>docker compose stop</code> in new version).</li>
<li>It will stop all running services at once.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-compose-publishing-ports"><a class="header" href="#docker-compose-publishing-ports">Docker Compose Publishing Ports</a></h1>
<hr />
<h2 id="publishing-ports"><a class="header" href="#publishing-ports">Publishing Ports</a></h2>
<ul>
<li>We made our app run with single command, but we were not able to access them.</li>
<li>To access our app we needed to publish the ports.</li>
<li>We know for <code>docker run</code> command we use <code>-p</code> option.</li>
<li>On compose we use <code>ports</code> property</li>
</ul>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
    image: amantuladhar/docker-kubernetes:v1-web
    ports:
      - 9090:8080
</code></pre>
<ul>
<li>You can publish any number of ports you want as you would with <code>-p</code> option.</li>
<li>You may have a hint on what docker-compose is trying to achieve.</li>
<li>If we publish ports with <code>docker run</code>, we need to specify that in every run.</li>
<li>But with compose, you don't need it.</li>
<li>We define the options in <code>yaml</code> file, and we simply use <code>docker-compose up</code>.</li>
<li>If you run your application now, you will be able to access it from the host.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-compose-logs"><a class="header" href="#docker-compose-logs">Docker Compose Logs</a></h1>
<hr />
<h2 id="accessing-logs"><a class="header" href="#accessing-logs">Accessing logs</a></h2>
<ul>
<li>If you run the app using <code>-d</code> option, you won't see the outputs (logs) on the screen.</li>
<li>If you want to access them or see them, you use <code>docker-compose logs @option @service</code> command.</li>
<li>If you run <code>docker-compose logs</code> it will show you all the logs for all <code>services</code>, but it won't show you new ones.</li>
<li>If you want to follow the logs in realtime you use <code>-f</code> option. <code>docker-compose logs -f</code>.</li>
<li>If you have multiple services, and you want to see logs for only single service, you can use: <code>docker-compose logs @options @serviceName</code> syntax.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-services"><a class="header" href="#multiple-services">Multiple Services</a></h1>
<hr />
<h2 id="defining-multiple-services"><a class="header" href="#defining-multiple-services">Defining Multiple Services</a></h2>
<ul>
<li>Docker compose shine when you want to run multi-container app.</li>
<li>Even if you want to run multiple container, you can run your app using single command.</li>
<li>Let's add <strong>mysql</strong> service in our compose file.</li>
</ul>
<blockquote>
<p>We will define <code>mysql</code> service but our app won't try to interact with database at the moment.</p>
</blockquote>
<pre><code class="language-yaml">services:
  myApp:
    image: amantuladhar/docker-kubernetes:v1-web
    ports:
      - 9090:8080
  myDb:                                    #  1
    image: mysql:5.7                       #  2
    environment:                           #  3
      - MYSQL_ROOT_PASSWORD=password       #  4
      - MYSQL_DATABASE=docker_kubernetes   #  4
</code></pre>
<ul>
<li><code>#1</code> name of new service.</li>
<li><code>#2</code> image you want to run. You can use <code>build</code> if you want to.</li>
<li><code>#3</code> Passing environment variables to image. Like we did with <code>-e</code> option.</li>
<li><code>#4</code> List of environment variables</li>
<li>One new thing in this service is that we are setting environment variables in the file.</li>
<li>Remember when you had to do this in command, those are old days now :).</li>
</ul>
<h2 id="listing-the-running-services"><a class="header" href="#listing-the-running-services">Listing the running services</a></h2>
<ul>
<li>If you want to list the running services you can use <code>docker-compose ps</code></li>
</ul>
<h2 id="attach-mysql-terminal"><a class="header" href="#attach-mysql-terminal">Attach <code>mysql</code> terminal</a></h2>
<ul>
<li><code>docker-compose exec @servicename @cmd</code></li>
<li>If you want to attach mysql pseudo tty to host, we can do that too.</li>
<li><code>docker-compose exec</code> by default attaches the pseudo tty so we don't need to add <code>-it</code> option.</li>
<li>If you don't want to attach pseudo-tty you can use <code>-T</code> option.</li>
<li>For now let's use <code>docker-compose exec myDb sh</code></li>
<li>Play around with the service, but remember data won't be persisted in next run</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="volumes"><a class="header" href="#volumes">Volumes</a></h1>
<hr />
<ul>
<li>We leaned how we can attach volumes using <code>docker run</code> command.</li>
<li>There was one problem, we had to use very long command.</li>
<li>Using big command is not a problem, if we use it only once or twice.</li>
<li>But we want to be able to run container multiple times.</li>
<li>You already know <code>docker-compse</code> tries to simply process of running container.</li>
<li>Compose supports volumes as well.</li>
<li>We simply use <code>volumes</code> properties for a service</li>
</ul>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
    image: amantuladhar/docker-kubernetes:v1-web
    ports:
      - 9090:8080
  myDb:
    image: mysql:5.7
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=docker_kubernetes
    volumes:                                       # 1
      - &quot;./volume/mysql-compose/:/var/lib/mysql/&quot;  # 2
</code></pre>
<ul>
<li><code>#1</code> we use <strong>volumes</strong> properties to map the volumes</li>
<li><code>#2</code> In this case we are mapping host volume to <code>/var/lib/mysql</code>.</li>
<li>Play around with the service.</li>
<li>Add a table, insert a data then, dispose all services and start up again.</li>
<li>Check if all data are still there.</li>
</ul>
<h2 id="different-ways-to-map-volumes"><a class="header" href="#different-ways-to-map-volumes">Different ways to map <code>volumes</code></a></h2>
<pre><code class="language-yaml">volumes:
  # Just specify a path and let the Engine create a volume
  - /var/lib/mysql

  # Specify an absolute path mapping
  - /opt/data:/var/lib/mysql

  # Path on the host, relative to the Compose file
  - ./cache:/tmp/cache

  # Named volume
  - datavolume:/var/lib/mysql
</code></pre>
<h2 id="named-volumes"><a class="header" href="#named-volumes">Named volumes</a></h2>
<ul>
<li>If you want to use named volume in docker-compose, you don't need to create one yourself.</li>
<li>You have <code>volumes</code> root property where you can define your volumes.</li>
</ul>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
    image: amantuladhar/docker-kubernetes:v1-web
    ports:
      - 9090:8080
  myDb:
    image: mysql:5.7
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=docker_kubernetes
    volumes:
      - &quot;./volume/mysql-compose/:/var/lib/mysql/&quot;
      - &quot;namedVolume:/test/path&quot;                   # 3                        
volumes:                                           # 1
  namedVolume:                                     # 2
</code></pre>
<ul>
<li><code>#1</code> root <code>volumes</code> property, where we can define <em>n</em> number for volumes.</li>
<li><code>#2</code> name of the volume. You can add some properties inside namedVolume too.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network"><a class="header" href="#network">Network</a></h1>
<hr />
<ul>
<li>Networks are also easy concept, we are not going to learn new stuff here.</li>
<li>We will just learn how to do same stuff, but more efficiently.</li>
<li>But at the end you will create an app that talks with database.</li>
<li>And most of all database values will be persisted.</li>
</ul>
<h2 id="setting-up-network"><a class="header" href="#setting-up-network">Setting Up Network</a></h2>
<ul>
<li>If you were paying attention to logs when we run our services, you saw that <code>docker-compose</code> creates a <code>default</code> network for us.</li>
<li>So all <strong>services</strong> defined on same file are already in same ( <code>default</code> ) network.</li>
</ul>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
    image: amantuladhar/docker-kubernetes:v1-web
    ports:
      - 9090:8080
  myTester:                               # 1
    image: amantuladhar/network-tools     # 2
    command: sleep 50000                  # 3
  myDb:
    image: mysql:5.7
...
...
</code></pre>
<ul>
<li><code>#1</code> Define one more service <code>myTester</code></li>
<li><code>#2</code> Use the image <code>amantuladhar/network-tools</code>. Remember when we learned networks, we used this to test connection between two containers.</li>
<li><code>#3</code> Overriding default <code>command</code> for an image, as this image doesn't have long-running process. This is so that it runs for a long period of time, and we can go inside the <strong>service</strong> and test our network.</li>
<li>I believe this is nothing new, we already did this before.</li>
<li>Only difference is that, now we are using compose, and it's convenience.</li>
</ul>
<h2 id="testing-network"><a class="header" href="#testing-network">Testing Network</a></h2>
<ul>
<li>Attach pseudo-tty of <code>myTester</code>.</li>
</ul>
<pre><code class="language-bash">docker-compose exec myTester sh
</code></pre>
<ul>
<li>Test the network like we did before.</li>
<li>We have to use <code>service_name</code> to communicate with other container.</li>
<li><code>localhost</code> will not work. We will learn how we can achieve this later.</li>
</ul>
<pre><code class="language-bash">/ # curl myApp:8080/test | jq .
{
  &quot;message&quot;: &quot;Hello Fellas!!!&quot;,
  &quot;host.address&quot;: &quot;192.168.48.2&quot;,
  &quot;app.version&quot;: &quot;v1-web&quot;
}
</code></pre>
<h2 id="named-network"><a class="header" href="#named-network">Named Network</a></h2>
<ul>
<li>While relying on <code>default</code> network works, you may want to name your network yourself.</li>
<li>You may even want to create multiple networks.</li>
<li>To achieve that we have <strong>networks</strong> root properties.</li>
<li>If we use it as a <strong>root</strong> property, we can define any number custom networks we want.</li>
<li>If used inside <strong>services</strong> property, it will make that particular <strong>service</strong> reside in the network.</li>
</ul>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
    image: amantuladhar/docker-kubernetes:v1-web
    ports:
      - 9090:8080
    networks:                              # 3     
      - myNet                              # 4    
  myTester:
    image: amantuladhar/network-tools
    command: sleep 50000
    networks:                              # 3    
      - myNet                              # 4    
  myDb:
    image: mysql:5.7
...
...
networks:                                  # 1
  myNet:                                   # 2
...
... 
</code></pre>
<ul>
<li><code>#1</code> this is a root property. This includes list of custom network you want to create.</li>
<li><code>#2</code> name of network you want to create.</li>
<li><code>#3</code> this is used inside <strong>services</strong>. This defines which network particular <strong>service</strong> communicates with.</li>
<li><code>#4</code> Name of networks <strong>service</strong> will use. You can add multiple networks</li>
<li>You can check if two containers can talk with each other like before.</li>
</ul>
<h2 id="using-network_mode"><a class="header" href="#using-network_mode">Using <code>network_mode</code></a></h2>
<ul>
<li>With help of <code>network_mode</code> property we can define the way container network are configured.</li>
<li>Remember <code>--net=container:@name</code> syntax. <code>network_mode</code> can achieve something like this.</li>
<li><code>network_mode</code> supports
<ul>
<li>&quot;bridge&quot;</li>
<li>&quot;host&quot;</li>
<li>&quot;none&quot;</li>
<li>&quot;service:@name&quot;</li>
<li>&quot;container:@id/@name&quot;</li>
</ul>
</li>
<li>For now, we will use <code>serrvice:@name</code> mode. Which I think will often be used than others.</li>
</ul>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
    image: amantuladhar/docker-kubernetes:v1-web
    ports:
      - 9090:8080
    networks:                                   
      - myNet                                 
  myTester:
    image: amantuladhar/network-tools
    command: sleep 50000
    network_mode: service:myApp           # 1
  myDb:
    image: mysql:5.7
...
...
...
</code></pre>
<ul>
<li><code>#1</code> This defines that we want to use same network that is being used by <strong>service</strong> <code>myApp</code>.</li>
<li>We are using <code>networks</code> properties for <code>**myApp**</code>, to define network for service.</li>
<li>Notice we didn't even have to define <code>networks</code> properties for <strong><code>myTester</code></strong>.</li>
<li>When defining a service you cannot use <code>ports</code> and <code>network_mode</code> properties at the same time.</li>
<li>Testing using <code>localhost</code> in <code>myTester</code></li>
</ul>
<pre><code class="language-bash">/ # curl localhost:8080/test
{
&quot;message&quot;: &quot;Hello Fellas!!!&quot;,
&quot;host.address&quot;: &quot;192.168.112.2&quot;,
&quot;app.version&quot;: &quot;v1-web&quot;
}
</code></pre>
<h2 id="web-app-with-database"><a class="header" href="#web-app-with-database">Web App With Database</a></h2>
<ul>
<li>You now have knowledge of how <code>docker-compose</code> and its component works.</li>
<li>Let's create a web app that connects with database.</li>
<li>You can use <code>amantuladhar/docker-kubernetes:v1-db</code> image to get the app that tries to connect with database.
<ul>
<li>This tag expects three environment variable: <code>DB_URL</code>, <code>DB_USER</code>, <code>DB_PASS</code>.</li>
</ul>
</li>
<li><a href="https://github.com/amantuladhar/DockerKubernetesFiles/tree/compose-db-initial">Web App With Database Example</a> branch <code>compose-db-initial</code> if you want to build it yourself.</li>
<li>Here's a compose file we are initially working with</li>
</ul>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
    image: amantuladhar/docker-kubernetes:v1-db
    ports:
      - 9090:8080
  myDb:
    image: mysql:5.7
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=docker_kubernetes
    volumes:
      - &quot;./volume/mysql-compose/:/var/lib/mysql/&quot;
networks:
  myNet:
</code></pre>
<ul>
<li>First step is to add <strong>network</strong> on both the <strong>services</strong>. (Or you can use default network).</li>
</ul>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
    image: amantuladhar/docker-kubernetes:v1-db
    ports:
      - 9090:8080
    networks:                                 # 1
      - myNet                                 # 1
  myDb:
    image: mysql:5.7
    networks:                                 # 1
      - myNet                                 # 1
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=docker_kubernetes
    volumes:
      - &quot;./volume/mysql-compose/:/var/lib/mysql/&quot;
networks:
  myNet:
</code></pre>
<ul>
<li><code>#1</code> added network to our services.</li>
<li>If you are using image above, it expected three stuff so that it can successfully connect with database.
<ul>
<li><code>DB_URL</code> Connection URL</li>
<li><code>DB_USER</code> Database User</li>
<li><code>DB_PASS</code> Database User Password</li>
</ul>
</li>
</ul>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
    image: amantuladhar/docker-kubernetes:v1-db
    ports:
      - 9090:8080
    networks:
      - myNet
    environment:                                                       # 1
      - DB_URL=jdbc:mysql://myDb:3306/docker_kubernetes?useSSL=false   # 2
      - DB_USER=root                                                   # 2
      - DB_PASS=password                                               # 2   
  myDb:
    image: mysql:5.7
    networks:
      - myNet
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=docker_kubernetes
    volumes:
      - &quot;./volume/mysql-compose/:/var/lib/mysql/&quot;
networks:
  myNet:
</code></pre>
<ul>
<li><code>#1</code> Using <code>environment</code> property to set our environment variable.</li>
<li><code>#2</code> Setting necessary environment variables.</li>
<li>If you run the services now you should be able to start your app and run it.</li>
</ul>
<h2 id="managing-service-start-order"><a class="header" href="#managing-service-start-order">Managing service start order</a></h2>
<ul>
<li>When using above compose file, it is not necessary that database starts first and web later.</li>
<li>Docker compose doesn't know which service to start first.</li>
<li>If our web app starts first and then database, clearly our app will fail.</li>
<li>To minimize such issues <code>docker-compose</code> has <code>depends_on</code> property that we can use.</li>
<li>We can add list of <strong>services</strong> particular service depends on and <code>docker-compose</code> will take care of starting them in order.</li>
</ul>
<blockquote>
<p><code>depends_on</code> does not wait for <code>mysql</code> to be <strong>ready</strong> before starting web only until they have been started.</p>
</blockquote>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
    image: amantuladhar/docker-kubernetes:v1-db
...
...
    depends_on:            &lt;-------------
      - myDb
  myDb:
    image: mysql:5.7
    networks:
      - myNet
...
...
networks:
  myNet:
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="restart-policy"><a class="header" href="#restart-policy">Restart Policy</a></h1>
<hr />
<ul>
<li><code>restart</code> property accepts the same values we learned before.
<ul>
<li>on-failure</li>
<li>unless-stopped</li>
<li>always</li>
<li>none</li>
</ul>
</li>
</ul>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
...
    restart: on-failure
... 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="health-check-1"><a class="header" href="#health-check-1">Health Check</a></h1>
<hr />
<h2 id="healthcheck-1"><a class="header" href="#healthcheck-1">healthcheck</a></h2>
<ul>
<li>We also have healthcheck property if we want to override the healthcheck of Image.</li>
<li>Like HEALTHCHECK instruction, we can provide different option to configure our healthcheck
<ul>
<li>interval</li>
<li>timeout</li>
<li>retries</li>
<li>start_period</li>
</ul>
</li>
</ul>
<pre><code class="language-yaml">version: '3'
services:
  myApp:
...
    healthcheck:
      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8080/test&quot;]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 20s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maven-docker-plugin-1"><a class="header" href="#maven-docker-plugin-1">Maven Docker Plugin</a></h1>
<hr />
<h2 id="docker-with-maven-basics"><a class="header" href="#docker-with-maven-basics">Docker with Maven Basics</a></h2>
<ul>
<li>We learned <code>docker</code> and <code>docker-compose</code> basics.</li>
<li>We can easily containerize our app, even if it needs database support.</li>
<li>While creating images manually by yourself can be done, more human interaction leads to more errors.</li>
<li>Delegating the image <code>build</code> process to maven gives you a lot of flexibility and also saves a lot of time.</li>
<li>This can be especially useful, if you have continuous integration flow set up, using Jenkins for example.</li>
<li>There are multiple maven plugins for docker. We will be working with
<ul>
<li><a href="https://github.com/fabric8io/docker-maven-plugin">fabric8io/docker-maven-plugin</a></li>
<li>I like this one as this has lots of options and is highly configurable.</li>
<li>So much that you don’t even need a Dockerfile to build your own image when using this plugin.</li>
</ul>
</li>
</ul>
<blockquote>
<p>For this chapter we will use <a href="https://github.com/amantuladhar/DockerKubernetesFiles/tree/dockerfile-initial-complete">Spring Simple Web App - <code>dockerfile-initial-complete</code></a> branch. </p>
</blockquote>
<h2 id="new-maven-goals"><a class="header" href="#new-maven-goals">New Maven Goals</a></h2>
<ul>
<li>If we use <a href="https://github.com/fabric8io/docker-maven-plugin">fabric8io/docker-maven-plugin</a>, we get few new maven goals.</li>
<li>Some important one that we will cover
<ul>
<li><code>docker:build</code>: This will build the docker image from the configuration we add to <code>pom.xml</code>.</li>
<li><code>docker:start/stop</code>: Run/Stop the image built from configuration.</li>
<li><code>docker:remove</code>: This is for cleaning up the images and containers.</li>
<li><code>docker:logs</code>: This prints out the output of the running containers.</li>
</ul>
</li>
</ul>
<h2 id="using-plugin"><a class="header" href="#using-plugin">Using Plugin</a></h2>
<ul>
<li>To use the plugin in you app, you need to add <a href="https://github.com/fabric8io/docker-maven-plugin">fabric8io/docker-maven-plugin</a> to you <code>pom.xml</code>.</li>
</ul>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;io.fabric8&lt;/groupId&gt;
            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;0.28.0&lt;/version&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<ul>
<li>This plugin supports lots of configuration, and we put the configuration inside <code>&lt;configuration&gt;</code> tag.</li>
</ul>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;io.fabric8&lt;/groupId&gt;
            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;0.28.0&lt;/version&gt;
            &lt;configuration&gt;
                &lt;verbose&gt;true&lt;/verbose&gt;
                &lt;images&gt;
                    &lt;image&gt;

                    &lt;/image&gt;
                &lt;/images&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<ul>
<li>The important part in the plugin definition is the <code>&lt;configuration&gt;</code> element.</li>
<li>It has <code>&lt;images&gt;</code> element which allows us to add multiple <code>&lt;image&gt;</code>.</li>
<li>There are two main elements in the <code>&lt;image&gt;</code>:
<ul>
<li>A <code>&lt;build&gt;</code> configuration specifying how images are built.</li>
<li>A <code>&lt;run&gt;</code> configuration describing how containers should be created and started. Think of this as option that you pass on <code>docker run</code> command.</li>
</ul>
</li>
<li>If you are using the app from GitHub you should have a <code>Dockerfile</code></li>
</ul>
<pre><code class="language-dockerfile">FROM openjdk:8-jre-alpine
WORKDIR /myApp
EXPOSE 8080
RUN apk add --no-cache curl
COPY [&quot;target/*.jar&quot;, &quot;./app.jar&quot;]
CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]
</code></pre>
<h2 id="using-dockerfile"><a class="header" href="#using-dockerfile">Using <code>Dockerfile</code></a></h2>
<ul>
<li>Let's add some configuration using <code>build</code> tag.</li>
</ul>
<pre><code class="language-xml">&lt;image&gt;
    &lt;name&gt;docker-kubernetes:${project.version}&lt;/name&gt;
    &lt;build&gt;
        &lt;dockerFileDir&gt;${project.basedir}&lt;/dockerFileDir&gt;
        &lt;dockerFile&gt;Dockerfile&lt;/dockerFile&gt;
    &lt;/build&gt;
&lt;/image&gt;
</code></pre>
<ul>
<li>To build the dockerfile you just need to run <code>./mvnw clean package docker:build</code>. It will build your app.</li>
<li>Default value for <code>&lt;dockerFileDir&gt;</code> is <code>/src/main/docker</code>.</li>
<li>We have our <code>Dockerfile</code> inside project root directory, so we are overriding the value.</li>
</ul>
<h2 id="run-using-dockerstart"><a class="header" href="#run-using-dockerstart">Run using <code>docker:start</code></a></h2>
<ul>
<li>It is as simple as <code>./mvnw package docker:start</code>.</li>
</ul>
<pre><code class="language-bash">...
[INFO] --- docker-maven-plugin:0.28.0:start (default-cli) @ cloudnative ---
[INFO] DOCKER&gt; [docker-kubernetes:v1-web]: Start container b9cbcab4c5a6
... 
</code></pre>
<ul>
<li>If you list the running container you can see that one container is running.</li>
<li>Of course, we cannot access the app, we haven't published the port yet.</li>
</ul>
<h2 id="stop-using-dockerstop"><a class="header" href="#stop-using-dockerstop">Stop using <code>docker:stop</code></a></h2>
<ul>
<li>To stop the running container you can use <code>./mvnw package docker:stop</code></li>
</ul>
<pre><code class="language-bash">...
[INFO] --- docker-maven-plugin:0.28.0:stop (default-cli) @ cloudnative ---
[INFO] DOCKER&gt; [docker-kubernetes:v1-web]: Stop and removed container b9cbcab4c5a6 after 0 ms
...
</code></pre>
<h2 id="port-publishing-1"><a class="header" href="#port-publishing-1">Port Publishing</a></h2>
<ul>
<li>We can publish the port easily as well.</li>
<li>For this plugin we add configuration inside <code>&lt;run&gt;</code> tag.</li>
<li>Inside <code>&lt;run&gt;</code> tag we use <code>&lt;ports&gt;</code> tag to expose ports.</li>
<li>Every port mapping are put inside <code>&lt;port&gt;</code> tag.</li>
</ul>
<pre><code class="language-xml">&lt;image&gt;
  &lt;name&gt;docker-kubernetes:${project.version}&lt;/name&gt;
  &lt;build&gt;
    &lt;dockerFileDir&gt;${project.basedir}&lt;/dockerFileDir&gt;
    &lt;dockerFile&gt;Dockerfile&lt;/dockerFile&gt;
  &lt;/build&gt;
  &lt;run&gt;
    &lt;ports&gt;
      &lt;port&gt;9090:8080&lt;/port&gt;
    &lt;/ports&gt;
  &lt;/run&gt;
&lt;/image&gt; 
</code></pre>
<ul>
<li><code>build</code> and <code>run</code> you app again and you will be able to access it from the host this time.</li>
</ul>
<h2 id="logs"><a class="header" href="#logs">Logs</a></h2>
<ul>
<li>If you want to see the logs just use <code>docker:logs</code> goal.</li>
</ul>
<h2 id="removing-images"><a class="header" href="#removing-images">Removing images</a></h2>
<pre><code class="language-bash">./mvnw clean package docker:remove
</code></pre>
<ul>
<li>This goal can be used to clean up images and containers.</li>
<li>By default, all images with a build configuration are removed.</li>
</ul>
<h2 id="build-image-without-dockerfile"><a class="header" href="#build-image-without-dockerfile">Build image without <code>Dockerfile</code></a></h2>
<ul>
<li>The plugin we are using supports creating <code>Dockerfile</code> in memory.</li>
<li>Inside the <code>&lt;build&gt;</code> tag, we can write <code>Dockerfile</code> like instructions.</li>
</ul>
<pre><code class="language-xml">&lt;image&gt;
  &lt;name&gt;docker-kubernetes:${project.version}&lt;/name&gt;
  &lt;build&gt;
    &lt;from&gt;openjdk:8-jre-alpine&lt;/from&gt;
    &lt;assembly&gt;
      &lt;descriptorRef&gt;artifact&lt;/descriptorRef&gt;
    &lt;/assembly&gt;
    &lt;cmd&gt;java -jar maven/${project.name}-${project.version}.jar&lt;/cmd&gt;
  &lt;/build&gt;
  &lt;run&gt;
    &lt;ports&gt;
      &lt;port&gt;9090:8080&lt;/port&gt;
    &lt;/ports&gt;
  &lt;/run&gt;
&lt;/image&gt; 
</code></pre>
<ul>
<li>
<p><code>&lt;from&gt;</code> is same as <code>FROM</code> instruction.</p>
</li>
<li>
<p><code>&lt;assembly&gt;</code> defines how build artifacts and other files can enter the Docker image. Using this we don't need to use <code>COPY</code> to copy our build artifact.</p>
</li>
<li>
<p>Inside <code>&lt;assembly&gt;</code> we are using <code>&lt;descriptorRef&gt;</code> which has some predefined ways to copy files to image.</p>
<ul>
<li><code>artifact-with-dependencies</code>: Attaches project’s artifact and all its dependencies.</li>
<li><code>artifact</code>: Attaches only the project’s artifact but no dependencies.</li>
<li><code>project</code>: Attaches the whole Maven project but without the target/ directory.</li>
<li><code>rootWar</code>: Copies the artifact as ROOT.war to the exposed directory. I.e. Tomcat will then deploy the war under the root context.</li>
</ul>
</li>
<li>
<p>We are using <code>artifact</code> pre-defined descriptor in our configuration, because we want to copy our <code>jar</code> file only.</p>
</li>
<li>
<p><code>&lt;cmd&gt;</code> is same as <code>CMD</code> instruction.</p>
</li>
<li>
<p>Build and run your app again. You will be able to access your app from the host.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="health-check-2"><a class="header" href="#health-check-2">Health Check</a></h1>
<hr />
<h2 id="run-command"><a class="header" href="#run-command">Run Command</a></h2>
<ul>
<li>How to add <code>RUN</code> instruction when using <code>in-memory</code> Dockerfile.</li>
</ul>
<pre><code class="language-xml">&lt;build&gt;
    ...
    &lt;runCmds&gt;
        &lt;run&gt;apk add --no-cache curl&lt;/run&gt;
    &lt;/runCmds&gt;
    &lt;cmd&gt;java -jar maven/${project.name}-${project.version}.jar&lt;/cmd&gt;
&lt;/build&gt;
</code></pre>
<ul>
<li><code>&lt;runCmds&gt;</code> can have multiple <code>&lt;run&gt;</code> tag.</li>
<li>Here we are installing <code>curl</code>.</li>
</ul>
<h2 id="restart-policy-1"><a class="header" href="#restart-policy-1">Restart Policy</a></h2>
<ul>
<li>If you want to restart policies for your images, you can use <code>&lt;restartPolicy&gt;</code> tag.</li>
</ul>
<pre><code class="language-xml">&lt;run&gt;
    &lt;restartPolicy&gt;
        &lt;name&gt;on-failure&lt;/name&gt;
        &lt;retry&gt;3&lt;/retry&gt;
    &lt;/restartPolicy&gt;
    ...
&lt;/run&gt; 
</code></pre>
<ul>
<li><code>&lt;restartPolicy&gt;</code> can is added inside of <code>&lt;run&gt;</code> tag.</li>
<li>It has <code>&lt;name&gt;</code> and <code>&lt;retry&gt;</code> children tag.</li>
<li><code>&lt;name&gt;</code> take the type of policy you want to enforce.</li>
<li><code>&lt;retry&gt;</code> how many times you want to restart your image, when <code>on-failure</code> policy is used.</li>
</ul>
<h2 id="health-check-3"><a class="header" href="#health-check-3">Health check</a></h2>
<ul>
<li>We can add a health check in our image as well.</li>
<li>We use <code>&lt;healthCheck&gt;</code> tag, which has few child tags.</li>
</ul>
<pre><code class="language-xml">&lt;build&gt;
    ...
    &lt;healthCheck&gt;
        &lt;interval&gt;10s&lt;/interval&gt;
        &lt;timeout&gt;5s&lt;/timeout&gt;
        &lt;startPeriod&gt;10s&lt;/startPeriod&gt;
        &lt;retries&gt;3&lt;/retry&gt;
        &lt;cmd&gt;curl --fail http://localhost:8080/test/status-5xx || exit 1&lt;/cmd&gt;
    &lt;/healthCheck&gt;
&lt;/build&gt;
</code></pre>
<ul>
<li>We use <code>&lt;healthCheck&gt;</code> tag inside <code>&lt;build&gt;</code> tag.</li>
<li>It has few children tags, which represents the option health check supports.</li>
<li><code>/test/status-5xx</code> will throw Internal Server Error after 6th request.</li>
<li>So for time being image will be healthy and after couple of minutes it will be tagged as unhealthy.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-container"><a class="header" href="#multiple-container">Multiple Container</a></h1>
<hr />
<h2 id="maven-plugin-running-multiple-container"><a class="header" href="#maven-plugin-running-multiple-container">Maven Plugin Running Multiple Container</a></h2>
<ul>
<li>With <strong>fabric8/docker-maven-plugin</strong> we can run multiple images.</li>
<li>Let's run <code>mysql</code>, but we won't run the app that talk with this database (for now).</li>
</ul>
<pre><code class="language-xml">&lt;images&gt;
    &lt;image&gt;
        &lt;name&gt;docker-kubernetes:${project.version}&lt;/name&gt;
        ...
    &lt;/image&gt;
    &lt;image&gt;
        &lt;name&gt;myDb:${project.version}&lt;/name&gt;
        &lt;alias&gt;myDb&lt;/alias&gt;
        &lt;build&gt;
            &lt;from&gt;mysql:5.7&lt;/from&gt;
        &lt;/build&gt;
        &lt;run&gt;
            &lt;env&gt;
                &lt;MYSQL_ROOT_PASSWORD&gt;password&lt;/MYSQL_ROOT_PASSWORD&gt;
                &lt;MYSQL_DATABASE&gt;docker_kubernetes&lt;/MYSQL_DATABASE&gt;
            &lt;/env&gt;
        &lt;/run&gt;
    &lt;/image&gt;
&lt;/images&gt;
</code></pre>
<ul>
<li>You just need to add another <code>&lt;image&gt;</code> tag inside <code>&lt;images&gt;</code> tag.</li>
<li>Here I am using <code>mysql:5.7</code> image.</li>
<li>Remember <code>mysql</code> expects that you pass some environment variable.</li>
<li>With <code>&lt;env&gt;</code> tag you can set the environment variable.</li>
<li>If you <code>docker:start</code> now, you will run both containers.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="volume"><a class="header" href="#volume">Volume</a></h1>
<hr />
<h2 id="maven-plugin-volumes"><a class="header" href="#maven-plugin-volumes">Maven Plugin Volumes</a></h2>
<ul>
<li>To mount the volume we have <code>&lt;volumes&gt;</code> tag.</li>
<li><code>&lt;volumes&gt;</code> tag has children tag <code>&lt;from&gt;</code> and <code>&lt;bind&gt;</code>.
<ul>
<li><code>&lt;from&gt;</code>: List of <code>&lt;image&gt;</code> elements which specify image names or aliases of containers whose volumes should be imported.</li>
<li><code>&lt;bind&gt;</code>: List of <code>&lt;volume&gt;</code> that maps host folder to container path.</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;images&gt;
    &lt;image&gt;
        &lt;name&gt;docker-kubernetes:${project.version}&lt;/name&gt;
        ...
    &lt;/image&gt;
    &lt;image&gt;
        &lt;name&gt;mydb:${project.version}&lt;/name&gt;
       ...
        &lt;run&gt;
            &lt;volumes&gt;
                &lt;bind&gt;
                    &lt;volume&gt;${project.basedir}/volume/mysql-plugin/:/var/lib/mysql/&lt;/volume&gt;
                &lt;/bind&gt;
            &lt;/volumes&gt;
            ...
        &lt;/run&gt;
    &lt;/image&gt;
&lt;/images&gt;
</code></pre>
<ul>
<li>I am saving mysql data in <code>${project.basedir}/volume/mysql-plugin/</code>.</li>
<li>Start the container, attach pseudo-tty of myDb container and then insert some data to database.</li>
<li>Stop and run the container again to see if data is saved.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-1"><a class="header" href="#network-1">Network</a></h1>
<hr />
<h2 id="maven-plugin-networks"><a class="header" href="#maven-plugin-networks">Maven Plugin Networks</a></h2>
<blockquote>
<p>For this chapter we will use <a href="https://github.com/amantuladhar/DockerKubernetesFiles/tree/plugin-db-initial">Simple App With DB - from <code>plugin-db-initial</code></a> branch.</p>
</blockquote>
<h2 id="auto-create-network"><a class="header" href="#auto-create-network">Auto Create Network</a></h2>
<ul>
<li>When dealing with network, we may need to create a network.</li>
<li>If we create a custom network, we need to create it manually.</li>
<li>Plugin that we are using can be configured so that custom network can be created automatically.</li>
<li>Just set <code>&lt;docker.autoCreateCustomNetworks&gt;</code> value to true and you will be all set.</li>
</ul>
<pre><code class="language-xml">&lt;properties&gt;
    ...
    &lt;docker.autoCreateCustomNetworks&gt;true&lt;/docker.autoCreateCustomNetworks&gt;
&lt;/properties&gt;
</code></pre>
<h2 id="create-a-network-1"><a class="header" href="#create-a-network-1">Create a network</a></h2>
<ul>
<li>To create a network we use <code>&lt;network&gt;</code> tag.</li>
<li><code>&lt;network&gt;</code> has few children.
<ul>
<li><code>mode</code>: The network mode, which can be one of the following values:</li>
<li><code>name</code>: For mode container this is the container name, which is this image alias. For Mode custom this is the name of the custom network.</li>
<li><code>alias</code>: One or more alias element can be provided which gives a way for a container to be discovered by alternate names by any other container within the scope of a particular network. This configuration only has effect for when the network mode is custom. More than one alias can be given by providing multiple entries.</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;image&gt;
    &lt;name&gt;docker-kubernetes:${project.version}&lt;/name&gt;
    ...
    &lt;run&gt;
        &lt;network&gt;
            &lt;mode&gt;custom&lt;/mode&gt;
            &lt;name&gt;mynet&lt;/name&gt;
        &lt;/network&gt;
        ...
        &lt;env&gt;
            &lt;DB_URL&gt;
                &lt;![CDATA[ jdbc:mysql://mysql_db:3306/docker_kubernetes?useSSL=false]]&gt;
            &lt;/DB_URL&gt;
            &lt;DB_USER&gt;root&lt;/DB_USER&gt;
            &lt;DB_PASS&gt;password&lt;/DB_PASS&gt;
        &lt;/env&gt;
    &lt;/run&gt;
&lt;/image&gt;
&lt;image&gt;
    &lt;name&gt;mydb:${project.version}&lt;/name&gt;
    &lt;alias&gt;mydb&lt;/alias&gt;
    ...
    &lt;run&gt;
        &lt;network&gt;
            &lt;mode&gt;custom&lt;/mode&gt;
            &lt;name&gt;mynet&lt;/name&gt;
            &lt;alias&gt;mysql_db&lt;/alias&gt;
        &lt;/network&gt;
        ...
        &lt;ports&gt;
            &lt;port&gt;4406:3306&lt;/port&gt;
        &lt;/ports&gt;
        &lt;env&gt;
            &lt;MYSQL_ROOT_PASSWORD&gt;password&lt;/MYSQL_ROOT_PASSWORD&gt;
            &lt;MYSQL_DATABASE&gt;docker_kubernetes&lt;/MYSQL_DATABASE&gt;
        &lt;/env&gt;
    &lt;/run&gt;
&lt;/image&gt;
</code></pre>
<ul>
<li>
<p>To add your container in a network, you use <code>&lt;network&gt;</code> tag inside <code>&lt;run&gt;</code> tag.</p>
</li>
<li>
<p><code>&lt;mode&gt;</code> can accept multiple value</p>
<ul>
<li><code>bridge</code> : Bridged mode with the default Docker bridge (default)</li>
<li><code>host</code> : Share the Docker host network interfaces</li>
<li><code>container</code> : Connect to the network of the specified container. The name of the container is taken from the <code>&lt;name&gt;</code> element.</li>
<li><code>custom</code> : Use a custom network, which must be created before by using docker network create.</li>
<li><code>none</code> : No network will be setup.</li>
</ul>
</li>
<li>
<p>In our case we are using <code>custom</code>, because we want to create our own network.</p>
</li>
<li>
<p><code>&lt;alias&gt;</code> is where we give a way for a container to be discovered by alternate names by any other container within the scope of a particular network.</p>
</li>
<li>
<p><strong>Notice:</strong> we are using same network on both image configuration. But on <strong>mysql</strong> part we are giving alias.</p>
</li>
<li>
<p>If you build and run the app, and your app will just work.</p>
</li>
</ul>
<h2 id="mode-container"><a class="header" href="#mode-container">mode <code>container</code></a></h2>
<ul>
<li>Using mode <code>container</code> you can access your network container using <code>localhost</code>.</li>
<li>But remember you have one big limitation, you cannot combine this with <code>&lt;ports&gt;</code>.</li>
</ul>
<pre><code class="language-xml">&lt;images&gt;
    &lt;image&gt;
        &lt;name&gt;docker-kubernetes:${project.version}&lt;/name&gt;
        &lt;alias&gt;my-app&lt;/alias&gt;
        ...
        &lt;run&gt;
            &lt;network&gt;
                &lt;mode&gt;custom&lt;/mode&gt;
                &lt;name&gt;mynet&lt;/name&gt;
            &lt;/network&gt;
            &lt;ports&gt;
                &lt;port&gt;9090:8080&lt;/port&gt;
            &lt;/ports&gt;
            &lt;env&gt;
                &lt;DB_URL&gt; &lt;![CDATA[ jdbc:mysql://localhost:3306/docker_kubernetes?useSSL=false ]]&gt; &lt;/DB_URL&gt;
                ...
            &lt;/env&gt;
        &lt;/run&gt;
    &lt;/image&gt;
    &lt;image&gt;
        &lt;name&gt;mydb:${project.version}&lt;/name&gt;
        &lt;alias&gt;mydb&lt;/alias&gt;
        &lt;build&gt;
            &lt;from&gt;mysql:5.7&lt;/from&gt;
        &lt;/build&gt;
        &lt;run&gt;
            &lt;network&gt;
                &lt;mode&gt;container&lt;/mode&gt;
                &lt;name&gt;my-app&lt;/name&gt;
            &lt;/network&gt;
            ...
        &lt;/run&gt;
    &lt;/image&gt;
&lt;/images&gt;
</code></pre>
<ul>
<li>We are still using <code>&lt;network&gt;</code> with <code>mode</code> <strong>custom</strong> on our web app side.</li>
<li>On database side, we are using <code>mode</code> <strong>container</strong> but instead of network name we are using our web app <strong>name</strong>.</li>
<li>We are using container <strong>alias</strong> here but you could have used <strong>name</strong> as well.</li>
</ul>
<h2 id="dependson"><a class="header" href="#dependson"><code>dependsOn</code></a></h2>
<ul>
<li>If you want to order which container start first you can use <code>depends_on</code>.</li>
<li>With the plugin we have <code>&lt;dependsOn&gt;</code> tag.</li>
</ul>
<pre><code class="language-xml">&lt;image&gt;
    &lt;name&gt;docker-kubernetes:${project.version}&lt;/name&gt;
    ...
    &lt;run&gt;
        ...
        &lt;dependsOn&gt;
            &lt;container&gt;mydb&lt;/container&gt;
        &lt;/dependsOn&gt;
    &lt;/run&gt;
&lt;/image&gt;
&lt;image&gt;
&lt;name&gt;mydb:${project.version}&lt;/name&gt;
&lt;alias&gt;mydb&lt;/alias&gt;
...
&lt;/image&gt; 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-kubernetes"><a class="header" href="#understanding-kubernetes">Understanding Kubernetes</a></h1>
<hr />
<h2 id="why-do-we-need-kubernetes"><a class="header" href="#why-do-we-need-kubernetes">Why do we need Kubernetes?</a></h2>
<ul>
<li>We learned <code>docker</code>, <code>docker-compose</code>. We know how to containerize our web app. Why do we need to learn yet another tool?</li>
<li>Note that <code>docker</code> and <code>docker-compose</code> runs on single host.</li>
<li>With help of Kubernetes we can run our app in multi-host environment.</li>
<li>With Kubernetes, we can easily deploy and run your software components without having to know about the actual servers underneath.</li>
<li>It doesn't matter if it has single host, or it has multiple-host or clusters.</li>
<li>When deploying a multi-component application through Kubernetes, it selects a server for each component, deploys it.</li>
<li>It also makes it easy to find and communicate with all the other components of your application.</li>
<li>Kubernetes enables you to run your applications on thousands of computer nodes as if all those nodes were a single, enormous computer.</li>
<li>It abstracts away the underlying infrastructure and, by doing so, simplifies development, deployment.</li>
<li>Kubernetes can be thought of as an operating system for the cluster</li>
</ul>
<h2 id="kubernetes-architecture-as-simple-as-possible"><a class="header" href="#kubernetes-architecture-as-simple-as-possible">Kubernetes Architecture As Simple As Possible</a></h2>
<ul>
<li>Kubernetes' architecture in its simplest form has two most important component.
<ul>
<li><strong>Kubernetes Master</strong></li>
<li><strong>Kubernetes Worker</strong></li>
</ul>
</li>
</ul>
<pre><code>                     Cloud
                    +----------------------+
                    |   +----------------+ |
User+-----------------&gt; |   Kubernetes   | |
                    |   |     Master     | |
                    |   +-------+--------+ |
                    |           |          |
                    |           |          |
                    |   +-------v--------+ |
                    |   |   Kubernetes   | |
                    |   |     Worker     | |
                    |   +----------------+ |
                    +----------------------+
</code></pre>
<h2 id="kubernetes-master"><a class="header" href="#kubernetes-master">Kubernetes Master</a></h2>
<ul>
<li>As a user we always communicate to <code>Kubernetes Master</code>. We will use <code>kubectl</code> tool to interact with <code>Kubernetes Master</code>.</li>
<li><code>Kubernetes Master</code> (Control Plane) has a subcomponents
<ul>
<li><code>Kubernetes API Server</code>, which you and the other Control Plane components communicate with</li>
<li><code>Scheduler</code>, which schedules your apps (assigns a worker node to each deployable component of your application)</li>
<li><code>Controller Manager</code>, which performs cluster-level functions, such as replicating components, keeping track of worker nodes, handling node failures, and so on</li>
<li><code>etcd</code>, a reliable distributed data store that persistently stores the cluster configuration.</li>
</ul>
</li>
</ul>
<pre><code>+-------------------------------------+
|                   +--------------+  |
|                   |   Scheduler  |  |
|                   +--------------+  |
|                                     |
|  +-----------+    +--------------+  |
|  |   API     |    |   Controller |  |
|  |   Server  |    |   Manager    |  |
|  +-----------+    +--------------+  |
|                                     |
|                   +--------------+  |
|                   |   etcd       |  |
|                   +--------------+  |
+-------------------------------------+
</code></pre>
<h2 id="kubernetes-worker"><a class="header" href="#kubernetes-worker">Kubernetes Worker</a></h2>
<ul>
<li><code>Kubernetes Worker</code> the run your containerized applications.</li>
<li>The task of running, monitoring, and providing services to your applications is done <code>Workers</code>.</li>
<li><code>Kubernetes Worker</code> have different components.
<ul>
<li><code>Container Runtime</code>: Docker, rkt, or another container runtime, which runs your containers.</li>
<li><code>Kubelet</code>, which talks to the <code>API server</code> and manages containers on its node.</li>
<li><code>Kubernetes Service Proxy (kube-proxy)</code>, which load-balances network traffic between application components.</li>
</ul>
</li>
</ul>
<pre><code>+------------------------------------------------+
|   +------------+          +-----------------+  |
|   |   kublet   |          |    kube-proxy   |  |
|   +------------+          +-----------------+  |
|                                                |
|           +-----------------------+            |
|           |    Container Runtime  |            |
|           +-----------------------+            |
+------------------------------------------------+
</code></pre>
<h2 id="nodes"><a class="header" href="#nodes">Nodes</a></h2>
<ul>
<li>Within a cloud we can have lots of nodes, which may or may not be on same machine.</li>
<li>It is a part of Kubernetes to abstract out these details.</li>
<li>We always communicate with <code>Master</code> which may be on same node as <code>Worker</code> or may be on different.</li>
</ul>
<pre><code>Cloud
+------------------------------------+
|                    +----------+    |
|                    |  Worker  |    |
|                    |   Node   |    |
|                    +----------+    |
|                                    |
|  +-----------+     +----------+    |
|  |   Master  |     |  Worker  |    |
|  |    Node   |     |   Node   |    |
|  +-----------+     +----------+    |
|                                    |
|                    +----------+    |
|                    |  Worker  |    |
|                    |   Node   |    |
|                    +----------+    |
+------------------------------------+
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pods"><a class="header" href="#pods">Pods</a></h1>
<hr />
<ul>
<li>Pods are the central, most important, concept in Kubernetes.</li>
<li>Pod represents the basic building block in Kubernetes and a place where containers are run.</li>
<li>When using Kubernetes you always deploy and operate on a pod of containers instead of deploying containers individually.</li>
<li>Pods can run more than one container, but it is good practice running one container per pod.</li>
</ul>
<blockquote>
<ul>
<li>We need to remember that Kubernetes manages Pods not containers.</li>
<li>So Kubernetes cannot scale individual containers, instead, it scales whole pods.</li>
</ul>
</blockquote>
<h2 id="points-when-running-multiple-container"><a class="header" href="#points-when-running-multiple-container">Points when running multiple container</a></h2>
<ul>
<li>Pods with multiple containers, are always run on a <strong>single worker node</strong> — it never spans multiple worker nodes.</li>
<li>A pod of containers allows you to run closely related processes together and provide them with (almost) the same environment as if they were all running in a single container, while keeping them somewhat isolated.</li>
<li>One thing to stress here is that because containers in a pod run in the same Network namespace, they share the same IP address and port space.</li>
<li>This means processes running in containers of the same pod need to take care not to bind to the same port numbers or they’ll run into port conflicts.</li>
</ul>
<h2 id=""><a class="header" href="#"></a></h2>
<p>Pods Configuration</p>
<ul>
<li>I am using this <a href="https://github.com/amantuladhar/DockerKubernetesFiles/tree/kub-pod-initial">kub-pod-initial</a> branch for this chapter.</li>
<li>We can create a Pods using command line but let's do it using <code>yaml</code> file.</li>
</ul>
<pre><code class="language-yaml">apiVersion: v1                                      # 1
kind: Pod                                           # 2
metadata:                                           # 3
  name: v1-web                                      # 4
spec:                                               # 5
  containers:                                       # 6
    - image: amantuladhar/docker-kubernetes:v1-web  # 7
      name: v1-web                                  # 8
      ports:                                        # 9
        - containerPort: 8080
</code></pre>
<ul>
<li><code>#1</code> <code>apiVersion</code> conforms which version to Kubernetes API to use.</li>
<li><code>#2</code> <code>kind</code> describes what kind of Kubernetes Resources we want to define.</li>
<li><code>#3</code> <code>metadata</code> is a place where you put information about the pods</li>
<li><code>#4</code> <code>name</code> Setting name for pod.</li>
<li><code>#5</code> <code>spec</code> contains a pods specification. Specification like container template, volumes etc.</li>
<li><code>#6</code> <code>containers</code> list of container you want Pods to have</li>
<li><code>#7</code> <code>image</code> defines which image to use.</li>
<li><code>#8</code> <code>name</code> name of container.</li>
<li><code>#9</code> <code>ports</code> List of port container listens to.</li>
<li>Specifying ports in the pod definition is purely informational.</li>
<li>Omitting them has no effect on whether clients can connect to the pod through the port.</li>
<li>But it makes sense to define the ports explicitly so that everyone using your cluster can quickly see what ports each pod exposes.</li>
</ul>
<h2 id="creating-pods"><a class="header" href="#creating-pods">Creating pods</a></h2>
<ul>
<li>To create a pod we have a simple command.</li>
<li><code>kubectl create -f pods.xml</code></li>
</ul>
<pre><code class="language-bash">kubectl create -f pods.yaml
pod/v1-web created
</code></pre>
<h2 id="list-pods"><a class="header" href="#list-pods">List Pods</a></h2>
<ul>
<li>To list the running pods, we can use</li>
<li><code>kubectl get pods</code> command.</li>
</ul>
<pre><code class="language-bash">➜ kubectl get pods           
NAME     READY   STATUS    RESTARTS   AGE
v1-web   1/1     Running   0          21m
</code></pre>
<h2 id="view-logs"><a class="header" href="#view-logs">View logs</a></h2>
<ul>
<li>Viewing logs is simple too <code>kubectl logs @pod_name</code></li>
<li><code>kubectl logs v1-web</code></li>
<li>If your pod includes multiple containers, you have to explicitly specify the container name by including the <code>-c &lt;container name&gt;</code>.</li>
</ul>
<h2 id="access-your-app"><a class="header" href="#access-your-app">Access your app</a></h2>
<ul>
<li>We ran our Pod, if you check the status it states it is running as well.</li>
<li>But how do we access our app?</li>
<li>Note: Pods are not meant to be accessed directly. We create some higher labels resources that abstracts these detail.</li>
<li>For debugging purposes, Kubernetes lets us access our Pods directly using <strong>port-forwarding</strong> technique.</li>
<li><code>kubectl port-forwarding @pod_name @host_port:@container_pod</code></li>
</ul>
<pre><code class="language-bash">➜ kubectl port-forward v1-web 9090:8080

Forwarding from 127.0.0.1:9090 -&gt; 8080
Forwarding from [::1]:9090 -&gt; 8080
</code></pre>
<ul>
<li>You need to keep this command running if you want to access your pod.</li>
<li>If you visit <code>localhost:9090/test</code>, you will be able to access you app.</li>
</ul>
<pre><code class="language-bash">➜ http localhost:9090/test
HTTP/1.1 200 
Content-Type: application/json;charset=UTF-8
Date: Sun, 17 Feb 2019 20:41:22 GMT
Transfer-Encoding: chunked

{
    &quot;app.version&quot;: &quot;v1-web&quot;,
    &quot;host.address&quot;: &quot;172.17.0.5&quot;,
    &quot;message&quot;: &quot;Hello Fellas!!!&quot;
}
</code></pre>
<h2 id="deleting-the-pods"><a class="header" href="#deleting-the-pods">Deleting the pods</a></h2>
<ul>
<li>Deleting the pods is simple too.</li>
<li><code>kubectl delete pods @pod_name</code></li>
</ul>
<pre><code class="language-bash">➜ kubectl delete pods v1-web           
pod &quot;v1-web&quot; deleted
</code></pre>
<h2 id="pod-labels"><a class="header" href="#pod-labels">Pod Labels</a></h2>
<ul>
<li>Labels are simply a tag given to pods which may help us identify the specific pods.</li>
<li>As our application grows number of pods increases, we need to categorize them so that we can manage them efficiently.</li>
<li>Labels are a simple, yet incredibly powerful feature in Kubernetes.</li>
<li>Labels can be added to pods, but also for all other resources Kubernetes has.</li>
<li>A label is an arbitrary key-value pair you attach to a resource.</li>
<li>It can be utilized when selecting resources using label selectors.</li>
<li>Resources are filtered based on whether they include the label specified in the selector.</li>
<li>A resource can have more than one label, as long as the keys of those labels are unique within that resource.</li>
<li>You usually attach labels to resources when you create them, but you can also add additional labels or even modify the values of existing labels later without having to recreate the resource.</li>
<li>Let's see how we can add them in <code>yaml</code></li>
<li>Labels are added in <code>metadata</code> section using <code>labels</code> property.</li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: v1-web
  labels:
    version: v1
    env: dev
spec:
  containers:
    - image: amantuladhar/docker-kubernetes:v1-web
      name: v1-web
      ports:
        - containerPort: 8080
</code></pre>
<ul>
<li>You can create a resource using <code>kubectl create -f pods.yaml</code>.</li>
</ul>
<h2 id="see-pods-labels"><a class="header" href="#see-pods-labels">See Pods labels</a></h2>
<ul>
<li>You can see pods labels in multiple ways</li>
</ul>
<h2 id="--show-labels"><a class="header" href="#--show-labels"><code>--show-labels</code></a></h2>
<ul>
<li>If you want to see all labels use <code>--show-labels</code> option when using <code>kubectl get pods</code>.</li>
<li><code>kubectl get pods --show-labels</code>.</li>
</ul>
<pre><code class="language-bash">➜ kubectl get pods --show-labels
NAME     READY   STATUS    RESTARTS   AGE     LABELS
v1-web   1/1     Running   0          2m38s   env=dev,version=v1
</code></pre>
<h2 id="using--l-option"><a class="header" href="#using--l-option">using <code>-L</code> option</a></h2>
<ul>
<li>While <code>--show-lables</code> options works fine.</li>
<li>What if we have lots of labels. Not that I am saying you should add many labels.</li>
<li>We can use <code>-L</code> options with the list of labels you want to see.</li>
<li><code>-L label_key1,label_key2</code></li>
</ul>
<pre><code class="language-bash">➜ kubectl get pods -L version,env
NAME     READY   STATUS    RESTARTS   AGE    VERSION   ENV
v1-web   1/1     Running   0          6m2s   v1        dev
</code></pre>
<h2 id="adding-new-label"><a class="header" href="#adding-new-label">Adding new label</a></h2>
<ul>
<li>If you want to change/add the labels for pads you can do it by stopping the pod and creating again.</li>
<li>But let's see how we can add new labels to running container</li>
<li>We use <code>kubectl label @resource @resource_name @label_key=@label_value</code></li>
<li>For us <code>@resource</code> is <strong>pods</strong>.</li>
</ul>
<pre><code class="language-bash">➜ kubectl label pods v1-web value=new
pod/v1-web labeled
</code></pre>
<ul>
<li>List the pods with labels and see the new value.</li>
</ul>
<pre><code class="language-bash">➜ kubectl get pods --show-labels     
NAME     READY   STATUS    RESTARTS   AGE   LABELS
v1-web   1/1     Running   0          14m   env=prod,value=new,version=v1
</code></pre>
<h2 id="updating-labels"><a class="header" href="#updating-labels">Updating labels</a></h2>
<ul>
<li>If we want to override the existing label, we can use the same command like above but we need to append <code>--overwrite</code> option as well.</li>
<li>We use <code>kubectl label @resource @resource_name @label_key=@label_value --overwrite</code></li>
<li>Let's change <code>env to dev</code> again.</li>
</ul>
<pre><code class="language-bash">➜ kubectl label pods v1-web env=dev --overwrite
pod/v1-web labeled
</code></pre>
<ul>
<li>List the labels</li>
</ul>
<pre><code class="language-bash">➜ kubectl get pods --show-labels               
NAME     READY   STATUS    RESTARTS   AGE   LABELS
v1-web   1/1     Running   0          16m   env=dev,value=new,version=v1
</code></pre>
<h2 id="list-the-pods-using-labels"><a class="header" href="#list-the-pods-using-labels">List the pods using labels</a></h2>
<ul>
<li>Listing pods using a label selector.</li>
<li>We use <code>-l</code> to add label criteria when listing the pods.</li>
</ul>
<h2 id="selecting-pods-with-specific-label-and-specific-value"><a class="header" href="#selecting-pods-with-specific-label-and-specific-value">Selecting pods with specific label and specific value</a></h2>
<pre><code class="language-bash">➜ kubectl get pods -l env=dev    
NAME     READY   STATUS    RESTARTS   AGE
v1-web   1/1     Running   0          51m
</code></pre>
<h2 id="selecting-pods-that-have-specific-label"><a class="header" href="#selecting-pods-that-have-specific-label">Selecting pods that have specific label</a></h2>
<ul>
<li>We can also select pods that have specific label, ignoring value it has.</li>
</ul>
<pre><code class="language-bash">➜ kubectl get pods -l env    
NAME     READY   STATUS    RESTARTS   AGE
v1-web   1/1     Running   0          53m 
</code></pre>
<h2 id="selecting-pods-that-dont-have-specific-label"><a class="header" href="#selecting-pods-that-dont-have-specific-label">Selecting pods that don't have specific label</a></h2>
<pre><code class="language-bash">➜ kubectl get pods -l '!env'
No resources found.
</code></pre>
<h2 id="deleting-pods-using-label-selectors"><a class="header" href="#deleting-pods-using-label-selectors">Deleting pods using label selectors</a></h2>
<ul>
<li>We already know how to delete a specific pod with name.</li>
<li>If we want to mass delete pods, we can use label selector criteria <code>-l</code> option.</li>
</ul>
<pre><code class="language-bash">➜ kubectl delete pods -l env
pod &quot;v1-web&quot; deleted
</code></pre>
<h2 id="deleting-all-pods-at-once"><a class="header" href="#deleting-all-pods-at-once">Deleting all pods at once</a></h2>
<ul>
<li>We can delete all pods at once using <code>kubectl delete pods --all</code></li>
</ul>
<h2 id="deleting-all-resource"><a class="header" href="#deleting-all-resource">Deleting all resource</a></h2>
<ul>
<li>We haven't learned about other type of resources, but if we want to delete all resources at once we can use.</li>
<li><code>kubectl delete all --all</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating-kubernetes-resource"><a class="header" href="#updating-kubernetes-resource">Updating Kubernetes Resource</a></h1>
<hr />
<h2 id="using-kubectl-edit"><a class="header" href="#using-kubectl-edit">Using <code>kubectl edit</code></a></h2>
<p>You can also use <code>kubectl edit rs @rs_name</code> and edit the <strong>yaml</strong> template</p>
<pre><code class="language-bash">kubectl edit rs v1-web
</code></pre>
<h2 id="using-kubectl-patch"><a class="header" href="#using-kubectl-patch">Using <code>kubectl patch</code></a></h2>
<ul>
<li>We can use <code>kubectl patch</code> to update the template of running resource.</li>
<li>You can pass either <code>JSON</code> or <code>YAML</code> when patching the resource.</li>
<li><code>kubectl patch @resource_type @resource_name --patch @template_subset</code></li>
</ul>
<pre><code class="language-bash">k patch pods v1-web --patch '{&quot;metadata&quot;: {&quot;labels&quot;: {&quot;version&quot;: &quot;v2&quot;}}}'
</code></pre>
<ul>
<li>In above command <code>--patch</code> takes a Kubernetes configuration file.</li>
<li>We can pass <code>yaml</code> like structure to <code>--patch</code> but I don't think will look good on a command. Plus the spacing and tabs will be tricky.</li>
<li>We are using <code>JSON</code> to send the patch.</li>
<li>We define properties we want to override. Notice that it is a subset of a full Kubernetes config.</li>
<li>When patching like this, we need to structure our data from <strong>root</strong> just like we do in config file.</li>
</ul>
<h2 id="using-kubectl-apply"><a class="header" href="#using-kubectl-apply">Using <code>kubectl apply</code></a></h2>
<ul>
<li>To update <strong>Resource Template</strong> for running resource as well.</li>
<li>To update the template for running resource you use <code>kubectl apply</code>.</li>
<li>Change you label <code>env to prod</code> at the moment.</li>
</ul>
<pre><code class="language-bash">➜ kubectl apply -f pods.yaml           
pod/v1-web configured
</code></pre>
<ul>
<li>List the labels again and you will see labels are changed.</li>
</ul>
<pre><code class="language-bash">➜ kubectl get pods -L version,env
NAME     READY   STATUS    RESTARTS   AGE     VERSION   ENV
v1-web   1/1     Running   0          8m51s   v1        prod
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="liveness-probe"><a class="header" href="#liveness-probe">Liveness Probe</a></h1>
<hr />
<ul>
<li>We learned how to add health check and restart policies in docker.</li>
<li>I also mentioned that Kubernetes as of now doesn't support these health check.</li>
<li>It cannot read the status set by docker and take action upon it.</li>
<li>For this reason, Kubernetes has concept of probes. Which is very simple but very powerful concept.</li>
<li>We will look into <code>liveness</code> probes for now.</li>
<li>Kubernetes can check if a container is still alive through <code>liveness</code> probes.</li>
<li>You can specify a <code>liveness</code> probe for each container in the pod’s specification.</li>
<li>Kubernetes will periodically execute the probe and restart the container if the probe fails.</li>
</ul>
<h2 id="types-of-liveness-probe"><a class="header" href="#types-of-liveness-probe">Types of <code>liveness probe</code></a></h2>
<ul>
<li>We can configure <code>liveness</code> probe for a container using one of the three method.
<ul>
<li>
<p><strong>HTTP GET probe</strong></p>
<ul>
<li>This performs HTTP GET request on the container’s IP address, a port and path you specify.</li>
<li>If the probe receives a response code of <strong>2xx</strong> or <strong>3xx</strong>, the probe is considered successful.</li>
<li>If the server returns an error response code or if it doesn’t respond at all, the probe is considered a failure.</li>
<li>Container whose <code>liveness</code> probe failed, will be restarted by Kubernetes.</li>
</ul>
</li>
<li>
<p><strong>TCP Socket probe</strong></p>
<ul>
<li>This configuration tries to open a TCP connection to the specified port of the container.</li>
<li>If the connection is established successfully, the probe is successful.</li>
<li>Otherwise, the container is restarted.</li>
</ul>
</li>
<li>
<p><strong>Exec probe</strong></p>
<ul>
<li>This executes an arbitrary command inside the container and checks the command’s exit status code.</li>
<li>If the status code is 0, the probe is successful.</li>
<li>All other codes are considered failures.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="adding-liveness-probe"><a class="header" href="#adding-liveness-probe">Adding Liveness Probe</a></h2>
<ul>
<li>Let's see how we can add liveness probe in our app.</li>
<li>We will use <code>httpGet</code> probe in our case.</li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: v1-web
  labels:
    version: v1
    env: prod
spec:
  containers:
    - image: amantuladhar/docker-kubernetes:v1-web
      name: v1-web
      livenessProbe:
        httpGet:
          path: /test
          port: 8080
      ports:
        - containerPort: 8080
</code></pre>
<h2 id="liveness-probe-in-action"><a class="header" href="#liveness-probe-in-action">Liveness Probe in Action</a></h2>
<ul>
<li>Let's create a resource using above configuration.</li>
<li>If you list the pods you will see our pod in running status.</li>
</ul>
<pre><code class="language-bash">NAME     READY   STATUS    RESTARTS   AGE   VERSION   ENV
v1-web   1/1     Running   0          32s   v1        prod
</code></pre>
<ul>
<li>If you call <code>localhost:9090/test/exit-1</code> you will exit our app.</li>
<li>Kubernetes when they run <code>liveness</code> probe doesn't respond, will tag pod status to <code>Error</code>.</li>
</ul>
<pre><code class="language-bash">NAME     READY   STATUS   RESTARTS   AGE   VERSION   ENV
v1-web   0/1     Error    0          21s   v1        prod
</code></pre>
<ul>
<li>Then it will restart your pod.</li>
</ul>
<pre><code class="language-bash">NAME     READY   STATUS    RESTARTS   AGE    VERSION   ENV
v1-web   1/1     Running   1          101s   v1        prod
</code></pre>
<ul>
<li>Notice <code>RESTARTS</code> column. The value indicates how many times your app restarted.</li>
</ul>
<h2 id="liveness-probe-options"><a class="header" href="#liveness-probe-options">Liveness Probe Options</a></h2>
<ul>
<li><code>initialDelaySeconds</code>: Number of seconds after the container has started before liveness probes are initiated.</li>
<li><code>periodSeconds</code>: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.</li>
<li><code>timeoutSeconds</code>: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1.</li>
<li><code>failureThreshold</code>: When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up. Giving up in case of liveness probe means restarting the Pod. Defaults to 3. Minimum value is 1.</li>
<li><code>successThreshold</code>: (Mostly used in readiness probe) we will discuss this later.</li>
</ul>
<pre><code class="language-yaml">livenessProbe:
    httpGet:
      path: /test/
      port: 8080
    initialDelaySeconds: 10
    periodSeconds: 60
    timeoutSeconds: 5
    failureThreshold: 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="replicaset"><a class="header" href="#replicaset">ReplicaSet</a></h1>
<hr />
<ul>
<li>We now know how to create pods, i.e. manually.</li>
<li>But in real world we never want to create a pod manually.</li>
<li>We always use higher level construct to manage pods.</li>
<li>One of the higher level construct that we use to manage pods is <code>ReplicaSet</code>. (Although we will use one more higher
level construct that manages <code>ReplicaSet</code> later).</li>
<li>A <code>ReplicaSet</code> ensures the pods it manages are always kept running.</li>
<li>If the pod disappears for any reason, <code>ReplicaSet</code> notices the missing pod and creates a replacement pod.</li>
</ul>
<h2 id="how-does-replicasets-work"><a class="header" href="#how-does-replicasets-work">How does <code>ReplicaSets</code> work?</a></h2>
<ul>
<li><code>ReplicaSet</code> constantly monitors the list of running pods.</li>
<li>Label selector is used to filter the pods that <code>ReplicaSet</code> manages.</li>
<li><code>ReplicaSet</code> makes sure the actual number of pods it manages always matches the desired number.</li>
<li>If too few such pods are running, it creates new replicas from a pod template.</li>
<li>If too many such pods are running, it removes the excess replicas.</li>
</ul>
<h1 id="defining-replicaset-yaml-file"><a class="header" href="#defining-replicaset-yaml-file">Defining <code>ReplicaSet</code> <code>yaml</code> file</a></h1>
<pre><code class="language-yaml">apiVersion: apps/v1             # 1                           
kind: ReplicaSet                # 2                      
metadata: # 3               
  name: v1-web                  # 4                    
  labels: # 5               
    version: v1                 # 5                     
    env: prod                   # 5                   
spec: # 6           
  replicas: 3                   # 6                   
  selector: # 8                 
    matchLabels: # 9                   
      version: v1               # 10                      
      env: prod                 # 10                  
  template:
    # After this it just a Pod template we had before                                                                   
    metadata:
      name: v1-web
      labels: # 11                                                
        version: v1             # 12                                                      
        env: prod               # 12                                                    
    spec:
      containers:
        - image: amantuladhar/docker-kubernetes:v1-web
          name: v1-web
          livenessProbe:
            httpGet:
              path: /test/
              port: 8080
          ports:
            - containerPort: 8080
</code></pre>
<ul>
<li><code>#1</code>: <code>ReplicaSet</code> are defined under <code>apiVersion</code> <strong>apps/v1</strong>.</li>
<li><code>#2</code>: We are setting our resource type to <code>ReplicaSet</code>.</li>
<li><code>#3</code>: Defines the metadata information for our resource.</li>
<li><code>#4</code>: We are setting the name for our <code>ReplicaSet</code>.</li>
<li><code>#5</code>: <code>labels</code> includes label added for a <code>ReplicaSet</code>.</li>
<li><code>#6</code>: <code>spec</code> includes the specification for our resource.</li>
<li><code>#7</code>: <code>replicas</code> tells ReplicaSet how many copies of pods we want. ReplicaSet make sure that specified number of pods
are always running.</li>
<li><code>#8</code>: <code>selector</code> will have list of labels that <code>ReplicaSet</code> will target. These are the labels that determines which
pods are managed by <code>ReplicaSet</code>. This selector must somehow match labels defined in <code>#12</code>, <code>#13</code>.</li>
<li><code>#9</code>: <code>matchLabels</code> indicate that we are trying to value label key with label value.
<ul>
<li>We also have <code>matchExpression</code> which is more expressive. (More on this later).</li>
</ul>
</li>
<li><code>template</code> is the template for the pod our ReplicaSet manages. When starting the ReplicaSet or adding new Pods, it
will use this template to start the Pod.
<ul>
<li>Notice: All properties below <code>template</code> is same as Pod <code>yaml</code> file we defined before.</li>
</ul>
</li>
</ul>
<h2 id="create-replicaset"><a class="header" href="#create-replicaset">Create <code>ReplicaSet</code></a></h2>
<ul>
<li>To create a <code>ReplicaSet</code> we simply use <code>kubectl create -f replicaset.yaml</code>.</li>
</ul>
<pre><code class="language-bash">➜ kubectl create -f replicaset.yaml
replicaset.apps/v1-web created 
</code></pre>
<h2 id="list-replicaset"><a class="header" href="#list-replicaset">List <code>ReplicaSet</code>.</a></h2>
<ul>
<li>To list the <code>ReplicaSet</code> we use same command like before but different resource.</li>
<li><code>kubectl get replicaset</code> or <code>kubectl get rs</code>.</li>
<li><code>rs</code> is the short form for <code>replicaset</code>.</li>
</ul>
<pre><code class="language-bash">➜ kubectl get replicaset           
NAME     DESIRED   CURRENT   READY   AGE
v1-web   3         3         3       42s

➜ kubectl get rs        
NAME     DESIRED   CURRENT   READY   AGE
v1-web   3         3         3       44s
</code></pre>
<h2 id="list-the-pods"><a class="header" href="#list-the-pods">List the pods</a></h2>
<ul>
<li>If you list the running pods, you will see you have three pods running.</li>
</ul>
<pre><code class="language-bash">➜ kubectl get po
NAME           READY   STATUS    RESTARTS   AGE
v1-web-8s5zw   1/1     Running   0          3m36s
v1-web-r9pkw   1/1     Running   0          3m36s
v1-web-xk9sk   1/1     Running   0          3m36s
</code></pre>
<ul>
<li><code>po</code> is short form for <code>pods</code>.</li>
</ul>
<h2 id="scaling-our-app"><a class="header" href="#scaling-our-app">Scaling our App</a></h2>
<h2 id="scale-up"><a class="header" href="#scale-up">Scale Up</a></h2>
<ul>
<li>
<p>If we ever want to scale up our application, it will be very easy now.</p>
</li>
<li>
<p>There are many ways you can scale your pods.</p>
<ul>
<li><code>kubectl patch</code></li>
<li><code>kubectl apply</code></li>
<li><code>kubectl edit</code></li>
<li><code>kubectl scale</code></li>
</ul>
</li>
<li>
<p>We already know how to use first three options from previous section.</p>
</li>
<li>
<p>Let's use fourth one</p>
</li>
</ul>
<h3 id="kubectl-scale"><a class="header" href="#kubectl-scale"><code>kubectl scale</code></a></h3>
<ul>
<li><code>kubectl scale rs --replicas=@number @rs_name</code></li>
<li>Using this command you can quickly change the number of replicas you want to run.</li>
</ul>
<pre><code class="language-dockerfile">➜ kubectl scale rs --replicas=10 v1-web
</code></pre>
<ul>
<li>List the pod again, you will see number of running pods will increase.</li>
</ul>
<pre><code class="language-bash">➜ kubectl get po
NAME           READY   STATUS    RESTARTS   AGE
v1-web-8s5zw   1/1     Running   0          6m48s
v1-web-fdnwf   1/1     Running   0          8s
v1-web-l6dbh   1/1     Running   0          8s
v1-web-lxkp7   1/1     Running   0          8s
v1-web-n6rfh   1/1     Running   0          8s
v1-web-q9zdq   1/1     Running   0          8s
v1-web-r9pkw   1/1     Running   0          6m48s
v1-web-s455s   1/1     Running   0          8s
v1-web-xctpn   1/1     Running   0          8s
v1-web-xk9sk   1/1     Running   0          6m48s
</code></pre>
<h2 id="scale-down"><a class="header" href="#scale-down">Scale Down</a></h2>
<ul>
<li>Scaling down is super easy as well.</li>
<li>Just update the replicas value. Set it to 3 for now.</li>
</ul>
<pre><code class="language-bash">➜ kubectl scale rs --replicas=3 v1-web
</code></pre>
<h2 id="replicaset-matchexpression"><a class="header" href="#replicaset-matchexpression">ReplicaSet <code>matchExpression</code></a></h2>
<ul>
<li>We saw how <code>matchLabels</code> works in previous example.</li>
<li>But <code>ReplicaSet</code> can have more expressive label selector than just matching key and value pairs.</li>
</ul>
<pre><code class="language-yaml">selector:
  matchExpressions:
    - key: @label_key
      operator: @operator_value
      values:
        - @label_value
        - @label_value 
</code></pre>
<ul>
<li>When we use <code>matchExpressions</code> we have few option that we can tweak.</li>
<li>We can have multiple <code>matchExpression</code> as well.</li>
<li><code>key</code> will take a <code>label</code> key.</li>
<li><code>operator</code> will take one of the pre-defined operators
<ul>
<li><code>In</code>: Label’s value must match one of the specified values.</li>
<li><code>NotIn</code>: Label’s value must not match any of the specified values.</li>
<li><code>Exists</code>: Pod must include a label with the specified key. When using this operator, you shouldn’t specify the
values field.</li>
<li><code>DoesNotExist</code>: Pod must not include a label with the specified key. The values property must not be specified.</li>
</ul>
</li>
<li><code>values</code>: If we use <code>In</code> or <code>NotIn</code> list of values to look for.</li>
<li>Let's generate the scenario where we can work on.</li>
<li>First run the <code>ReplicaSet</code> yaml file you had before.</li>
<li>You will end up with three Pods. Override one of Pod label <strong>env=prod to env=dev</strong></li>
<li>The Pod whose label was change is now no longer managed by our ReplicaSet.</li>
<li>Now ReplicaSet will create a new Pod to match the desired state.</li>
<li>If you list the running Pod you will see we have 4 pods. (3 managed by ReplicaSet, 1 not)</li>
</ul>
<pre><code class="language-bash">➜ kubectl get pods -L version,env                    
NAME           READY   STATUS    RESTARTS   AGE   VERSION   ENV
v1-web-8s5zw   1/1     Running   0          31m   v1        dev
v1-web-njbt9   1/1     Running   0          5s    v1        prod
v1-web-r9pkw   1/1     Running   0          31m   v1        prod
v1-web-xk9sk   1/1     Running   0          31m   v1        prod 
</code></pre>
<ul>
<li>How do we tell <code>ReplicaSet</code> to manage Pods with label env=dev and env=prod.</li>
<li>How to not create extra Pod?</li>
</ul>
<h2 id="using-operator"><a class="header" href="#using-operator">Using Operator</a></h2>
<ul>
<li>Let's update our <code>ReplicaSet</code> label selector to</li>
</ul>
<pre><code class="language-yaml">selector:
  matchExpressions:
    - key: env
      operator: In
      values:
        - dev
        - prod 
</code></pre>
<ul>
<li>Using <code>In</code> we can define that ReplicaSet can look for either value <code>dev</code> or <code>prod</code> for label <code>env</code>.</li>
<li>If we update one of the pod label env to dev now, it won't create new Pod. As updated Pod is still managed
by <code>ReplicaSet</code> and replicas count match the desired state.</li>
</ul>
<pre><code class="language-bash">➜ kubectl label po v1-web-6bcgx env=dev --overwrite
pod/v1-web-6bcgx labeled
</code></pre>
<ul>
<li>Now list the pods.</li>
</ul>
<pre><code class="language-bash">NAME           READY   STATUS    RESTARTS   AGE     VERSION   ENV
v1-web-6bcgx   1/1     Running   0          6m22s   v1        dev
v1-web-mkk79   1/1     Running   0          6m22s   v1        prod
v1-web-sxl59   1/1     Running   0          6m22s   v1        prod 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service"><a class="header" href="#service">Service</a></h1>
<hr />
<ul>
<li>Now we know how to manage Pods using <code>ReplicaSet</code>.</li>
<li>You know that <code>ReplicaSet</code> make sure that desired number of Pods are always alive.</li>
<li>One very important thing we should remember is that Pods are disposable, they should be easily replaceable.</li>
<li>Another thing we need to remember is that, there can be multiple Pods that serves the same content.</li>
<li>How do we keep tract of Pods IP. Pods can scale up / down, how to know new IP of pods when they are added.</li>
<li>If Pods is unhealthy, they are replaced. They may or may not get the same IP.</li>
</ul>
<h2 id="what-is-service"><a class="header" href="#what-is-service">What is Service</a></h2>
<ul>
<li>Service is a resource that makes a single, constant point of entry to a group of pods providing the same service.</li>
<li>Each service is assigned a IP and port that never change while the service exists.</li>
<li>Using service IP we can communicate with Pods that service manages.</li>
<li>Service also manages Pods using label selector.</li>
</ul>
<h2 id="service-definition"><a class="header" href="#service-definition">Service Definition</a></h2>
<ul>
<li>To create a Service, you create a resource with <code>kind: Service</code></li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: Service            # 1
metadata:
  name: v1-web-svc       # 2
spec:
  type: NodePort         # 3
  ports:
    - port: 80           # 4
      targetPort: 8080   # 5
      nodePort: 30000    # 6
  selector:              # 7
    env: prod
    version: v1 
</code></pre>
<ul>
<li><code>#1</code>: We are defining the type of resource to <code>Service</code>.</li>
<li><code>#3</code>: Type of Service. Default is <code>ClusterIP</code> but if we use <code>ClusterIP</code> it be visible only inside cluster.
<ul>
<li><code>NodePort</code> will expose set of Pod it manages to external client.</li>
</ul>
</li>
<li><code>#4</code>: Expose external endpoint to port 80. Type <code>NodePort</code> will ignore this properties.</li>
<li><code>#5</code>: <code>targetPort</code> is the port container serves the app.</li>
<li><code>#6</code>: <code>nodePort</code> will use this IP to expose the service to external client. It must be range from 30000-32767.</li>
<li><code>#7</code>: This is the label selector that is used by Service to select the Pods.</li>
<li><code>minikube</code> doesn't support <code>LoadBalancer</code> as of now.</li>
</ul>
<h2 id="create-a-service"><a class="header" href="#create-a-service">Create a Service</a></h2>
<ul>
<li>You can create a service by using <code>kubectl create -f svc.yaml</code>.</li>
</ul>
<pre><code>                 +----------------------------------+
+--------+       |          +-----------+           |
|External+-----------------&gt;|  Service  |           |
| Client |       |          +-----+-----+           |
+--------+       |                |                 |
                 |    +------------------------+    |
                 |    |           |            |    |
                 |  +-v-+       +-v-+        +-v-+  |
                 |  |Pod|       |Pod|        |Pod|  |
                 |  +---+       +---+        +---+  |
                 +----------------------------------+
</code></pre>
<h2 id="list-service"><a class="header" href="#list-service">List Service</a></h2>
<ul>
<li>To list the services in cluster you use <code>kubectl get svc</code>, where <code>svc</code> is short form for service.</li>
</ul>
<h2 id="access-the-pods-externally"><a class="header" href="#access-the-pods-externally">Access the Pods externally</a></h2>
<ul>
<li>Now that service is running, we can access our app from outside.</li>
<li>If you try <code>localhost:30000/test</code> it will not work. Why?</li>
<li>Remember Kubernetes is running inside minikube cluster, which is running inside Virtual Machine.</li>
<li>We can use <code>minikube service @service_name</code> to easily access your services through your browser.
<ul>
<li><code>minikube ip</code> echos the minikube IP.</li>
<li><code>minikube service @service_name --url</code> echos the IP with port instead of opening browser.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="readiness-probe"><a class="header" href="#readiness-probe">Readiness Probe</a></h1>
<hr />
<h2 id="why-do-we-need-readiness-probe"><a class="header" href="#why-do-we-need-readiness-probe">Why do we need <code>readiness probe</code>?</a></h2>
<ul>
<li>We learned how to use <code>ReplicaSet</code>, with that we also learned how to increase number of running Pods.</li>
<li>With <code>Service</code> we learned how to expose them, with single IP. <code>Service</code> allows us to access our Pods without knowing it's actual IP.</li>
<li>But when does the <code>Service</code> starts to send a traffic to Pod when we scale up your app?</li>
</ul>
<h2 id="understanding-the-problem"><a class="header" href="#understanding-the-problem">Understanding the problem.</a></h2>
<ul>
<li>Create a <code>ReplicaSet</code> that runs only 1 copy of our app at the moment.</li>
<li>Run this command, this will call you app endpoint every second.</li>
</ul>
<pre><code class="language-bash">while true ; do curl http://192.168.99.106:30000/test ; echo &quot;\\n&quot; ; sleep 1 ; done;
</code></pre>
<ul>
<li>Instead of IP above, use your own IP.</li>
<li>Now scale up your app. Run 3 replicas.</li>
<li>You will start to get some failed request.</li>
</ul>
<pre><code class="language-bash">{&quot;message&quot;:&quot;Hello Fellas!!!&quot;,&quot;host.address&quot;:&quot;172.17.0.5&quot;,&quot;app.version&quot;:&quot;v1-web&quot;}

curl: (7) Failed to connect to 192.168.99.106 port 30000: Connection refused
curl: (7) Failed to connect to 192.168.99.106 port 30000: Connection refused
curl: (7) Failed to connect to 192.168.99.106 port 30000: Connection refused


{&quot;message&quot;:&quot;Hello Fellas!!!&quot;,&quot;host.address&quot;:&quot;172.17.0.5&quot;,&quot;app.version&quot;:&quot;v1-web&quot;}
{&quot;message&quot;:&quot;Hello Fellas!!!&quot;,&quot;host.address&quot;:&quot;172.17.0.5&quot;,&quot;app.version&quot;:&quot;v1-web&quot;}

curl: (7) Failed to connect to 192.168.99.106 port 30000: Connection refused
curl: (7) Failed to connect to 192.168.99.106 port 30000: Connection refused
curl: (7) Failed to connect to 192.168.99.106 port 30000: Connection refused


{&quot;message&quot;:&quot;Hello Fellas!!!&quot;,&quot;host.address&quot;:&quot;172.17.0.7&quot;,&quot;app.version&quot;:&quot;v1-web&quot;}
{&quot;message&quot;:&quot;Hello Fellas!!!&quot;,&quot;host.address&quot;:&quot;172.17.0.7&quot;,&quot;app.version&quot;:&quot;v1-web&quot;}
{&quot;message&quot;:&quot;Hello Fellas!!!&quot;,&quot;host.address&quot;:&quot;172.17.0.6&quot;,&quot;app.version&quot;:&quot;v1-web&quot;}
{&quot;message&quot;:&quot;Hello Fellas!!!&quot;,&quot;host.address&quot;:&quot;172.17.0.6&quot;,&quot;app.version&quot;:&quot;v1-web&quot;}
{&quot;message&quot;:&quot;Hello Fellas!!!&quot;,&quot;host.address&quot;:&quot;172.17.0.5&quot;,&quot;app.version&quot;:&quot;v1-web&quot;}
</code></pre>
<ul>
<li>Why is this happening?</li>
<li>What happens right now is that, <code>Service</code> starts to send the traffic to a Pod as soon as Pod is started.</li>
<li>Kubernetes at the moment doesn't have any idea if our Pod is ready to accept connection.</li>
<li>To help with this problem we use <code>readiness</code> probe.</li>
</ul>
<h2 id="what-is-readiness-probe"><a class="header" href="#what-is-readiness-probe">What is <code>readiness</code> probe?</a></h2>
<ul>
<li>We learned the <code>liveness</code> probe before.</li>
<li>With help of <code>liveness</code> probe we were able to restart the Pods that were unhealthy.</li>
<li>With the help of <code>readiness</code> probe, Kubernetes will be able to know if Pods are ready to accept connection.</li>
<li>Like <code>liveness</code>, <code>readiness</code> probe is also executed periodically.</li>
<li>The result determines if Pods is ready or not.</li>
</ul>
<h2 id="types-of-readiness-probe"><a class="header" href="#types-of-readiness-probe">Types of <code>readiness</code> probe</a></h2>
<ul>
<li>Like <code>liveness</code> probe, we have three ways
<ul>
<li><code>Exec</code></li>
<li><code>HTTP GET</code></li>
<li><code>TCP Socket</code></li>
</ul>
</li>
</ul>
<h2 id="add-readiness-probe"><a class="header" href="#add-readiness-probe">Add <code>readiness</code> probe</a></h2>
<ul>
<li>To add a <code>readiness</code> probe, we can add it using <code>readinessProbe</code> properties.</li>
</ul>
<pre><code class="language-yaml"># ReplicaSet Definition
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  ...
spec:
  replicas: 3
  ...
  spec:
    containers:
        - image: amantuladhar/docker-kubernetes:v1-web
          name: v1-web-con
          readinessProbe:            # 1
            httpGet:                 # 2
              path: /test/           # 3
              port: 8080             # 4
            initialDelaySeconds: 10  # 5
          ... 
</code></pre>
<ul>
<li><code>#1</code> we use <code>readinessProbe</code> property to add probe in our Pod template.</li>
<li><code>#2</code> we are using <code>httpGet</code> way of defining probe</li>
<li><code>#3</code> Which path to ping</li>
<li><code>#4</code> Which port to expose</li>
<li><code>#5</code> How many seconds do we delay before sending first probe request.</li>
</ul>
<h2 id="readiness-probe-options"><a class="header" href="#readiness-probe-options"><code>Readiness</code> probe options</a></h2>
<ul>
<li>Like <code>liveness</code> probe we have few options we can configure
<ul>
<li><code>initialDelaySeconds</code>: Number of seconds after the container has started before liveness probes are initiated.</li>
<li><code>periodSeconds</code>: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.</li>
<li><code>timeoutSeconds</code>: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1.</li>
<li><code>failureThreshold</code>: When a Pod starts and the probe fails, Kubernetes will try failureThreshold times before giving up. Giving up in case of liveness probe means restarting the Pod. Defaults to 3. Minimum value is 1.</li>
<li><code>successThreshold</code>: Minimum consecutive successes for the probe to be considered successful after having failed</li>
</ul>
</li>
</ul>
<pre><code class="language-yaml">readinessProbe:
    httpGet:
      path: /test/
      port: 8080
    initialDelaySeconds: 10
    successThreshold: 1
    periodSeconds: 60
    timeoutSeconds: 5
    failureThreshold: 3
</code></pre>
<h2 id="readiness-probe-in-action"><a class="header" href="#readiness-probe-in-action"><code>Readiness</code> probe in action</a></h2>
<ul>
<li>Create a <code>ReplicaSet</code> that runs only 1 copy of our app at the moment.</li>
<li>Run this command, this will call you app endpoint every second.</li>
</ul>
<pre><code class="language-bash">while true ; do curl http://192.168.99.106:30000/test ; echo &quot;\\n&quot; ; sleep 1 ; done;
</code></pre>
<ul>
<li>Instead of IP above, use your own IP.</li>
<li>Now scale up your app. Run 3 replicas.</li>
<li>You will only see response from other Pod when they are ready.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-deployment"><a class="header" href="#creating-deployment">Creating Deployment</a></h1>
<hr />
<ul>
<li>We learned few type of Kubernetes Resource
<ul>
<li>Service</li>
<li>Pod</li>
<li>ReplicaSet</li>
</ul>
</li>
<li>While Service is a higher-level concept we be creating in the future, Pods and ReplicaSet are considered lower-level concept.</li>
<li><code>Deployment</code> doesn't manage our app, but rather <code>Deployment</code> creates a ReplicaSet which in turns manages Pods.</li>
<li><code>Deployment</code> is a way to define the states of our application declaratively.</li>
<li>With help of <code>Deployment</code> we can easily deploy our application, plus it is super easy to update them.</li>
<li><code>Deployment</code> shines when we are about to upgrade the app to new version.</li>
<li>Out of the box it supports rolling updates, but other strategies are also easily achievable. We will discuss deployment strategies later.</li>
</ul>
<pre><code>+----------+          +----------+
|Deployment+---------&gt;+ReplicaSet|
+----------+          +------+---+
                             |
                             |
  +------------+-------------+
  |            |             |
+-v-+        +-v-+         +-v-+
|Pod|        |Pod|         |Pod|
+---+        +---+         +---+

</code></pre>
<h2 id="creating-deployment-1"><a class="header" href="#creating-deployment-1">Creating Deployment</a></h2>
<ul>
<li>Creating <code>Deployment</code> is same as creating <code>ReplicaSet</code></li>
<li>If you have <code>ReplicaSet</code> config file from before, you can easily make it <code>Deployment</code> resource.</li>
<li>Actually we can even delete some properties. We will delete it later, and explain why we can delete them.</li>
<li>For now let's replace the property <code>kind: Service</code> to <code>kind: Deployment</code>.</li>
<li>And there you have it. You just created your <code>Deployment</code> resource.</li>
</ul>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment       # kind: ReplicaSet
metadata:
  name: web
  labels:
    version: v1
    env: prod
spec:
  replicas: 3
  selector:
    matchLabels:
      env: prod
      version: v1
  template:
    metadata:
      name: web
      labels:
        version: v1
        env: prod
    spec:
      containers:
        - image: amantuladhar/docker-kubernetes:v1-web
          name: web
          # Liveness &amp; readiness probe
          ports:
            - containerPort: 8080
</code></pre>
<ul>
<li>If you create a resource using <code>kubectrl create -f deployment.yaml</code> you will create your resources.</li>
<li>If you list the resources, you can see <code>Deployment</code> will create <code>ReplicaSet</code>, <code>Pods</code>.</li>
<li>Number of Pods also match the <code>replicas: @number.</code></li>
</ul>
<h2 id="deployment-doesnt-create-service"><a class="header" href="#deployment-doesnt-create-service">Deployment doesn't create <code>Service</code></a></h2>
<ul>
<li>If you listed the resources <code>kubectl get all</code> you may have noticed, we don't have our Service running.</li>
<li>To access Pods we need to create a <code>Service</code>.</li>
</ul>
<h2 id="rolling-out-update"><a class="header" href="#rolling-out-update">Rolling out Update</a></h2>
<h2 id="upgrade-the-app-v2"><a class="header" href="#upgrade-the-app-v2">Upgrade the app (<code>V2</code>)</a></h2>
<pre><code class="language-yaml">containers:
  - image: amantuladhar/docker-kubernetes:v2-web
    name: web
</code></pre>
<ul>
<li>Now let's create update start the update process</li>
<li>You can use <code>kubectl apply -f deployment.yaml</code></li>
<li>By default <code>Deployment</code> favors rolling update.</li>
</ul>
<blockquote>
<p>Because Deployment is not tied to specific version of app, we can delete the label version label selector from our yaml file.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rolling-update-deployment-strategy"><a class="header" href="#rolling-update-deployment-strategy">Rolling Update Deployment Strategy</a></h1>
<hr />
<ul>
<li>Rolling Deployment is a process of replacing currently running instances of our application with newer ones.</li>
<li>When using this deployment process, there will be a point of time when two version of our app will be running.</li>
</ul>
<pre><code>                  +-------+      +-------+
                  |Replica|---+-&gt;+ Pod_1 |
     +-----------&gt;| Set_1 |   |  +-------+
     |            +-------+   |
     |                        |  +-------+
+----+-----+                  +-&gt;+ Pod_1 |
|Deployment|                  |  +-------+
+----------+                  |
                              |  +-------+
                              +-&gt;+ Pod_1 |
                                 +-------+

</code></pre>
<ul>
<li>This is the initial state for our <code>v1</code> app. Because we said we needed 3 replicas.</li>
<li>After the update, Kubernetes will start you update with rolling update strategy.</li>
</ul>
<h2 id="how-rolling-update-is-done"><a class="header" href="#how-rolling-update-is-done">How Rolling Update is done?</a></h2>
<pre><code>                                 +-------+
                              +-&gt;+ Pod_1 |
                              |  +-------+
                              |
                  +-------+   |  +-------+
                  |Replica+-----&gt;+ Pod_1 |
     +-----------&gt;+ Set_1 |   |  +-------+
     |            +-------+   |
     |                        |  +-------+
+----+-----+                  +-&gt;+ Pod_1 |
|Deployment|                     +-------+
+----+-----+
     |            +-------+
     |            |Replica|      +-------+
     +-----------&gt;+ Set_2 +-----&gt;+ Pod_2 | |Running|!Ready|
                  +-------+      +-------+

</code></pre>
<ul>
<li>After we start update process, Kubernetes will create a second <code>ReplicaSet</code>.</li>
<li>It will also spin up one new <code>Pod</code>. This can be configured, which we will discuss later.</li>
<li>At the moment, there are 4 pods <strong>running</strong> but only three are in <strong>ready</strong> state. <code>Pod_2</code> was just created, and it takes time to be <strong>ready</strong>.</li>
<li>After <code>Pod_2</code> is ready, it will terminate one of the <code>Pod_1</code> and create a new <code>Pod_2</code></li>
</ul>
<pre><code>                                 +-------+
                              +-&gt;+ Pod_1 |
                              |  +-------+
                              |
                  +-------+   |  +-------+
                  |Replica+-----&gt;+ Pod_1 |
     +-----------&gt;+ Set_1 |   |  +-------+
     |            +-------+   |
     |                        |  +-------+
+----+-----+                  +-&gt;+ |---| |  |Terminating|
|Deployment|                     +-------+
+----+-----+
     |            +-------+
     |            |Replica|      +-------+
     +-----------&gt;+ Set_2 +---+-&gt;+ Pod_2 |  |Running|Ready|
                  +-------+   |  +-------+
                              |
                              |  +-------+
                              +-&gt;+ Pod_2 |  |Running|!Ready|
                                 +-------+

</code></pre>
<ul>
<li>After new <code>Pod_2</code> is ready, it will terminate another <code>Pod_1</code> and then continue like this until new <code>ReplicaSet</code> desired state is not met.</li>
</ul>
<blockquote>
<p>When using Rolling Update strategy, user won't see any downtime.
Also two version of the app will run during update process</p>
</blockquote>
<pre><code>                  +-------+
                  |Replica|
     +-----------&gt;+ Set_1 |
     |            +-------+
     |
+----+-----+                     +-------+
|Deployment|                  +-&gt;+ Pod_2 |
+----+-----+                  |  +-------+
     |            +-------+   |
     |            |Replica|   |  +-------+
     +-----------&gt;+ Set_2 +-----&gt;+ Pod_2 |
                  +-------+   |  +-------+
                              |
                              |  +-------+
                              +-&gt;+ Pod_2 |
                                 +-------+
</code></pre>
<ul>
<li>This will be the final state of our update process.</li>
<li>From the diagram, you can see that <code>Deployment</code> doesn't delete the old <code>ReplicaSet</code>.</li>
<li>But having old <code>ReplicaSets</code> may not be ideal.</li>
<li>We can configure how many <code>ReplicaSet</code> to save using <code>revisionHistoryLimit</code> property on the Deployment resource.</li>
<li>It <strong>defaults</strong> to two, so normally only the current and the previous revision are shown in the history and only the current and the previous ReplicaSet are preserved.</li>
<li>Older ReplicaSets are deleted automatically.</li>
</ul>
<h2 id="status-of-update-process"><a class="header" href="#status-of-update-process">Status of update process</a></h2>
<ul>
<li>We have a <code>kubectl rollout</code> command which has lots of helper function that helps us to interact with <code>Deployment</code> resource.</li>
<li>One of them is to see the status of <code>Deployment</code> update process.</li>
<li><code>kubectl rollout status @resource_type @resource_name</code></li>
</ul>
<pre><code class="language-bash">kubectl rollout status deployment web
</code></pre>
<ul>
<li>This will log the phases Kubernetes is going through when updating our app.</li>
</ul>
<h2 id="controlling-rollout-speed"><a class="header" href="#controlling-rollout-speed">Controlling Rollout Speed</a></h2>
<ul>
<li>You can control the speed at which Pods are replaced using two Kubernetes properties.</li>
<li>If you inspect the <code>Deployment</code> property you can see default value Kubernetes sets for these properties</li>
</ul>
<pre><code class="language-bash">➜ k describe deployments.apps web              
Name:                   web
Namespace:              default
Labels:                 env=prod
                        version=v1
Annotations:            deployment.kubernetes.io/revision: 5
...
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
... 
</code></pre>
<ul>
<li>You can see we have two property</li>
</ul>
<h2 id="maxunavailable"><a class="header" href="#maxunavailable"><code>maxUnavailable</code></a></h2>
<ul>
<li>Specifies the maximum number of Pods that can be unavailable during the update process.</li>
<li>The value can be an absolute number (for example, 5) or a percentage of desired Pods (for example, 10%).</li>
<li>The absolute number is calculated from percentage by rounding down.</li>
<li>The value cannot be 0 if <code>maxSurge</code> is 0.</li>
<li>The default value is 25%.</li>
</ul>
<h2 id="maxsurge"><a class="header" href="#maxsurge"><code>maxSurge</code></a></h2>
<ul>
<li>Specifies the maximum number of Pods that can be created over the desired number of Pods.</li>
<li>The value can be an absolute number (for example, 5) or a percentage of desired Pods (for example, 10%).</li>
<li>The value cannot be 0 if <code>maxUnavailable</code> is 0.</li>
<li>The absolute number is calculated from the percentage by rounding up.</li>
<li>The default value is 25%.</li>
</ul>
<h2 id="setting-the-values"><a class="header" href="#setting-the-values">Setting the values</a></h2>
<ul>
<li>All of these properties are defined under <code>spec.strategy.rollingUpdates</code></li>
</ul>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
# metadata
spec:
  strategy:
    type: RollingUpdate # Default
    rollingUpdate:
      maxSurge: 2
      maxUnavailable: 1
  # other props
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rolling-back-update"><a class="header" href="#rolling-back-update">Rolling Back Update</a></h1>
<hr />
<ul>
<li>From the previous section, you saw updating app with the new version was so easy.</li>
<li>You just update the image you want to use and Kubernetes does most of the work for us.</li>
<li>But what if the new version of app we just updated has some bug.</li>
<li>What is bug turned out to be severe. We need to roll back the updates as fast as possible. We can't let user use unstable app.</li>
<li>With Kubernetes, rolling back is just as easy.</li>
</ul>
<h2 id="using-kubectl-rollout-undo-to-roll-back-update"><a class="header" href="#using-kubectl-rollout-undo-to-roll-back-update">Using <code>kubectl rollout undo</code> to roll back update</a></h2>
<ul>
<li>We can use <code>kubectl rollout undo @resource_type @resource_name</code> syntax to undo the update process.</li>
<li>It is very easy to do so.</li>
</ul>
<h2 id="history-of-deployment-rollout"><a class="header" href="#history-of-deployment-rollout">History of <code>Deployment</code> rollout</a></h2>
<ul>
<li>You can easily see history revision history</li>
<li><code>kubectl rollout history @resource_type @resource_name</code></li>
</ul>
<pre><code class="language-bash">➜ kubectl rollout history deployment web                                    
deployment.extensions/web 
REVISION  CHANGE-CAUSE
1         &lt;none&gt;
2         &lt;none&gt;
3         &lt;none&gt; 
</code></pre>
<ul>
<li>If we do one little extra step, when creating / rolling out the update, we can see some values in <code>CHANGE-CAUSE</code> column.</li>
<li>If when creating / updating we use <code>--record</code> option. It will record the command we used to make an update.</li>
<li>The command is then visible in <code>CHANGE-CAUSE</code> column.</li>
</ul>
<pre><code class="language-bash">➜ kubectl rollout history deployment web                                             
deployment.extensions/web 
REVISION  CHANGE-CAUSE
2         &lt;none&gt;
3         &lt;none&gt;
4         kubectl set image deployment web web=amantuladhar/docker-kubernetes:v1-web --record=true 
</code></pre>
<h2 id="getting-more-detail-on-history"><a class="header" href="#getting-more-detail-on-history">Getting more detail on history</a></h2>
<ul>
<li>You can see more detail of particular revision by using <code>--revision=@revision_number</code> option.</li>
</ul>
<pre><code class="language-bash">➜ kubectl rollout history deployment web --revision 4
deployment.extensions/web with revision #4
Pod Template:
  Labels:       env=prod
        pod-template-hash=6445f5654d
        version=v1
  Annotations:  kubernetes.io/change-cause: kubectl set image deployment web web=amantuladhar/docker-kubernetes:v1-web --record=true
  Containers:
   web:
    Image:      amantuladhar/docker-kubernetes:v1-web
    Port:       8080/TCP
    Host Port:  0/TCP
    Liveness:   http-get http://:8080/test/ delay=10s timeout=1s period=30s #success=1 #failure=3
    Readiness:  http-get http://:8080/test/ delay=10s timeout=1s period=10s #success=1 #failure=3
    Environment:        &lt;none&gt;
    Mounts:     &lt;none&gt;
  Volumes:      &lt;none&gt; 
</code></pre>
<h2 id="rolling-back-to-specific-revision"><a class="header" href="#rolling-back-to-specific-revision">Rolling Back to specific revision</a></h2>
<ul>
<li>We can control number of revision history to retain using <code>revisionHistoryLimit</code> property.</li>
<li>If there are multiple revision we can jump back to particular revision as well</li>
<li><code>kubectl rollout undo @resource_type @resource_name --to-revision=@revision_number</code></li>
</ul>
<pre><code class="language-bash">➜ kubectl rollout undo deployment web --to-revision=2
deployment.extensions/web rolled back
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="failed-deployment"><a class="header" href="#failed-deployment">Failed Deployment</a></h1>
<hr />
<ul>
<li>When upgrading you application to new version, Kubernetes might not be able to deploy the latest version of your application.</li>
<li>This can happen due to multiple reasons
<ul>
<li>Insufficient resource</li>
<li>Readiness Probe failures</li>
<li>Image Pull Errors etc.</li>
</ul>
</li>
<li>Kubernetes can automatically detect if upgrade revision is bad</li>
</ul>
<h2 id="specminreadyseconds"><a class="header" href="#specminreadyseconds"><code>spec.minReadySeconds</code></a></h2>
<ul>
<li><code>spec.minReadySeconds</code> is an optional field that specifies the minimum number of seconds for which a newly created Pod should be ready.</li>
<li>Ready meaning any of its containers should not crash.</li>
<li>This <strong>defaults</strong> to 0 i.e. the Pod will be considered available as soon as it is ready.</li>
<li>If <code>Deployment</code> has only readiness probe, it will mark Pod as available as soon as its <code>readiness</code> probe succeeds.</li>
<li>With <code>minReadySeconds</code> we can take our <code>readiness</code> probe one step further.</li>
<li>If our <code>readiness</code> probe starts failing before <code>minReadySeconds</code> , the rollout of new version will be blocked.</li>
</ul>
<h2 id="specprogressdeadlineseconds"><a class="header" href="#specprogressdeadlineseconds"><code>spec.progressDeadlineSeconds</code></a></h2>
<ul>
<li>We can configure when Kubernetes marks Deployment as failed by property<code>spec.progressDeadlineSeconds</code></li>
<li><code>spec.progressDeadlineSeconds</code> is an optional field that specifies the number of seconds you want to wait for your Deployment to progress before the system reports back that the Deployment has failed.</li>
<li>If specified, this field needs to be greater than <code>spec.minReadySeconds</code></li>
</ul>
<blockquote>
<p>In the future, once automatic rollback will be implemented, the deployment controller will roll back a Deployment as soon as it observes such a condition.</p>
</blockquote>
<h2 id="rollout-v1-app"><a class="header" href="#rollout-v1-app">Rollout v1 app</a></h2>
<ul>
<li>Let's start with this <code>Deployment</code> file</li>
</ul>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  #metadata
spec:
  minReadySeconds: 20
  progressDeadlineSeconds: 30
  strategy:
    type: RollingUpdate # Default
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  # replicas, selector
  template:
    #metadata
    spec:
      containers:
        - image: amantuladhar/docker-kubernetes:v1-web
          name: web
          readinessProbe:
            httpGet:
              path: /test/
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 1
          #liveness probe &amp; ports
</code></pre>
<ul>
<li><code>minReadySeconds</code> is set to 20 seconds.
<ul>
<li>That means even if our <code>readiness</code> probe succeeds before 20 seconds deployment is not considered successful.</li>
<li>Kubernetes will execute <code>readiness</code> probe multiple times within <code>minReadySecond</code> time frame.</li>
<li>If within that time period <code>readiness</code> probe fails deployment is considered unsuccessful.</li>
<li>Remember Pod <strong>Ready</strong> status will be updated by <code>readiness</code> probe but <code>Deployment</code> has its own status to check if deployment process was success or failure.</li>
</ul>
</li>
<li><code>progressDeadlineSeconds</code> is set to 30 seconds.
<ul>
<li>Kubernetes will wait for 30 seconds before it sets the deployment process status.</li>
</ul>
</li>
<li><code>maxSurge</code> is set to 1
<ul>
<li>Relative to <code>replicas</code> number, Kubernetes will create only 1 extra Pod.</li>
</ul>
</li>
<li><code>maxUnavailable</code> is set to 0.
<ul>
<li>Kubernetes will always have desired <code>replicas</code> running.</li>
</ul>
</li>
<li>Without setting <code>maxSurge</code> 1 and <code>maxUnavailable</code> 0, we are asking Kubernetes to create a new Pod and only delete existing Pod when new one is ready.</li>
<li><code>readinessProbe</code> to check if our Pod is ready. We are running our probe every second.</li>
</ul>
<h2 id="rollout-v2"><a class="header" href="#rollout-v2">Rollout v2</a></h2>
<ul>
<li>To roll out v2, only thing we need to do is update the image the value.</li>
<li>But for our test we will update <code>readiness</code> probe as well.</li>
<li>We will point <code>readiness</code> probe to <code>/test/status-5xx</code> endpoint.</li>
<li>This endpoint will return status <strong>200</strong> for first 5 calls, but after that <strong>500</strong>. (Trying to emulate situation where app run for a while and after some time it starts to crash).</li>
</ul>
<pre><code class="language-yaml"># other props
spec:
  # other props
  template:
    #other props
    spec:
      containers:
        - image: amantuladhar/docker-kubernetes:v2-web
          name: web
          readinessProbe:
            httpGet:
              path: /test/status-5xx
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 1
          #other props
</code></pre>
<ul>
<li>Of course in real world we won't change <code>readiness</code> probe path, but for this test we are changing it.</li>
</ul>
<h2 id="rollout-status"><a class="header" href="#rollout-status">Rollout Status</a></h2>
<ul>
<li>After we apply our update, Kubernetes will start deployment process.</li>
<li>It will create a new Pod with new version of our app.</li>
</ul>
<pre><code class="language-bash">NAME                       READY   STATUS    RESTARTS   AGE
pod/web-5577ff7d67-fp6ht   0/1     Running   0          1m
pod/web-697456ff84-29tm8   1/1     Running   0          17m
pod/web-697456ff84-jhd2c   1/1     Running   0          17m
pod/web-697456ff84-vvtkd   1/1     Running   0          17m
</code></pre>
<ul>
<li>Initially it won't be <strong>Ready.</strong></li>
<li>But after your app starts for a brief period of moment, new Pod will have status Ready. (Remember for first 5 calls our endpoint works.)</li>
</ul>
<pre><code class="language-bash">NAME                       READY   STATUS    RESTARTS   AGE
pod/web-5577ff7d67-fp6ht   1/1     Running   0          2m
pod/web-697456ff84-29tm8   1/1     Running   0          23m
pod/web-697456ff84-jhd2c   1/1     Running   0          23m
pod/web-697456ff84-vvtkd   1/1     Running   0          23m
</code></pre>
<ul>
<li>If we don't define <code>minReadySeconds</code> at this point, Kubernetes will terminate one of the older Pod and create a new one.</li>
<li>But because we did and time we defined on <code>minReadySeconds</code> has still not passed, readiness probes continues to check if probe is ready.</li>
<li>Because of the way we configured our readiness probe, our probe will fail before the <code>minReadySeconds</code></li>
<li>After that Pod Ready status will be changed.</li>
</ul>
<pre><code class="language-bash">NAME                       READY   STATUS    RESTARTS   AGE
pod/web-5577ff7d67-fp6ht   0/1     Running   0          5m
pod/web-697456ff84-29tm8   1/1     Running   0          24m
pod/web-697456ff84-jhd2c   1/1     Running   0          24m
pod/web-697456ff84-vvtkd   1/1     Running   0          24m 
</code></pre>
<ul>
<li>After <code>progressDeadlineSeconds</code> is passed, Kubernetes will set the status of deployment. For our case it failed as Pod is not Ready.</li>
<li>If we were running <code>kubectl rollout status deployment web</code> we will see following log.</li>
</ul>
<pre><code class="language-bash">➜ k rollout status deployment web
Waiting for deployment &quot;web&quot; rollout to finish: 1 out of 3 new replicas have been updated...
Waiting for deployment &quot;web&quot; rollout to finish: 1 out of 3 new replicas have been updated...
Waiting for deployment &quot;web&quot; rollout to finish: 1 out of 3 new replicas have been updated...
Waiting for deployment &quot;web&quot; rollout to finish: 1 out of 3 new replicas have been updated...
error: deployment &quot;web&quot; exceeded its progress deadline
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recreate-deployment-strategy"><a class="header" href="#recreate-deployment-strategy">Recreate Deployment Strategy</a></h1>
<hr />
<ul>
<li>Recreate strategy is a simple approach of Deployment.</li>
<li>If we use this strategy, Kubernetes will delete all existing version of Pods, only then it will create a new one.</li>
<li>For a brief period of time our server will not be able to handle request.</li>
</ul>
<h2 id="setting-strategy"><a class="header" href="#setting-strategy">Setting strategy</a></h2>
<ul>
<li>Setting <code>Recreate</code> strategy in Kubernetes is easy.</li>
<li>Just set <code>spec.strategy.type</code> to <code>Recreate</code></li>
</ul>
<h2 id="how-recreate-strategy-works"><a class="header" href="#how-recreate-strategy-works">How Recreate strategy works</a></h2>
<ul>
<li>When we deploy our first version, Kubernetes will make sure it matches our desired state.</li>
</ul>
<pre><code class="language-bash">                                 +-------+
                              +-&gt;+ Pod_1 |
                              |  +-------+
                              |
                  +-------+   |  +-------+
                  |Replica+-----&gt;+ Pod_1 |
     +-----------&gt;+ Set_1 |   |  +-------+
     |            +-------+   |
     |                        |  +-------+
+----+-----+                  +-&gt;+ Pod_1 |
|Deployment|                     +-------+
+----------+
</code></pre>
<ul>
<li>When we start our upgrade process, Kubernetes will stop all our container.</li>
<li>It will delete the Pods that are running old version of app.</li>
</ul>
<pre><code class="language-bash">                                 +-------+
                              +-&gt;+ |-----| |Terminating|
                              |  +-------+
                              |
                  +-------+   |  +-------+
                  |Replica+-----&gt;+ |---| | |Terminating|
     +-----------&gt;+ Set_1 |   |  +-------+
     |            +-------+   |
     |                        |  +-------+
+----+-----+                  +-&gt;+ |-----| |Terminating|
|Deployment|                     +-------+
+----------+

</code></pre>
<ul>
<li>After all old Pods are deleted, Kubernetes will start a new Pod with out v2 app.</li>
</ul>
<pre><code class="language-bash">                 +-------+
                  |Replica|
     +-----------&gt;+ Set_1 |
     |            +-------+
     |
+----+-----+                     +-------+
|Deployment|                  +-&gt;+ Pod_2 |
+----+-----+                  |  +-------+
     |            +-------+   |
     |            |Replica|   |  +-------+
     +-----------&gt;+ Set_2 +-----&gt;+ Pod_2 |
                  +-------+   |  +-------+
                              |
                              |  +-------+
                              +-&gt;+ Pod_2 |
                                 +-------+
</code></pre>
<ul>
<li>After this our deployment process is finished.</li>
</ul>
<blockquote>
<p>Note: Kubernetes creates a new ReplicaSet for this deployment strategy as well. This is so that we can easily roll back to previous version.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blue-green-deployment"><a class="header" href="#blue-green-deployment">Blue Green Deployment</a></h1>
<hr />
<p>Blue Green Deployment</p>
<blockquote>
<p>Kubernetes doesn't have (as of now) <code>strategy: BlueGreen</code> like we had <code>RollingUpdate</code> and <code>Recreate</code>.</p>
</blockquote>
<h2 id="how-blue-green-deployment-strategy-works"><a class="header" href="#how-blue-green-deployment-strategy-works">How blue-green deployment strategy works?</a></h2>
<ul>
<li>If we want to upgrade the instances of <strong>V1 (Blue),</strong> we create exactly the same number of instances of <strong>V2 (Green)</strong> alongside <strong>V1 (Blue)</strong>.</li>
<li>Initially <strong>Service</strong> that we are using to expose our app will be pointing to <strong>V1 (Blue)</strong>.</li>
<li>After testing that the <strong>V2 (Green)</strong> meets all the requirements the traffic is switched from <strong>V1 (Blue)</strong> to <strong>V2 (Green).</strong></li>
<li>This technique reduces downtime by running two version of app at the same time.
<ul>
<li>But only one version of app is live to user.</li>
<li>For our example, Blue is currently live, and Green is idle.</li>
<li>But after upgrade Green will be live, and Blue will be idle. (Later on Blue will be deleted)</li>
</ul>
</li>
</ul>
<h3 id="advantages"><a class="header" href="#advantages">Advantages</a></h3>
<ul>
<li>With this strategy we can have instant roll back, as we still have old version of app running in background.</li>
<li>Unlike Rolling Update we don't run two version of app once.</li>
</ul>
<h3 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages</a></h3>
<ul>
<li>Blue Green deployment strategy might be expensive. When updating the app we use double resource.</li>
</ul>
<h2 id="blue-green-stages"><a class="header" href="#blue-green-stages">Blue Green Stages</a></h2>
<h3 id="initial-state"><a class="header" href="#initial-state">Initial State</a></h3>
<pre><code>                       +-------------+
                       |             |
               +-------+   Service   |
               |       |             |
               |       +-------------+
               |
               |
   |BLUE|      v
+---------------------------+
|   +-------------------+   |
|   |Pod_1||Pod_1||Pod_1|   |
|   --------------------+   |
| -------------+  +-------+ |
| |Deployment_1|  |Replica| |
| -------------+  | Set_1 | |
|                 +-------+ |
+---------------------------+
</code></pre>
<ul>
<li>Initially we will have V1 app running, for now let's say Blue.</li>
</ul>
<h3 id="rollout-update"><a class="header" href="#rollout-update">Rollout Update</a></h3>
<pre><code>                       +--------------+
                       |              |
               +-------+    Service   |
               |       |              |
               |       +--------------+
               |
               |
   |BLUE|      v                    |GREEN|
+---------------------------+     +---------------------------+
|   +-------------------+   |     |   +-------------------+   |
|   |Pod_1||Pod_1||Pod_1|   |     |   |Pod_2||Pod_2||Pod_2|   |
|   --------------------+   |     |   --------------------+   |
|                           |     |                           |
|                           |     |                           |
| -------------+  +-------+ |     | -------------+  +-------+ |
| |Deployment_1|  |Replica| |     | |Deployment_2|  |Replica| |
| -------------+  | Set_1 | |     | -------------+  | Set_2 | |
|                 +-------+ |     |                 +-------+ |
+---------------------------+     +---------------------------+

</code></pre>
<ul>
<li>When rollout starts we create our V2 (Green), ideally we will create same number of Pods replicas.</li>
<li>Notice, we are creating totally new <code>Deployment</code> here.</li>
</ul>
<h3 id="switch-to-new-version"><a class="header" href="#switch-to-new-version">Switch to new version</a></h3>
<pre><code>                       +--------------+
                       |              |
                       |    Service   +------+
                       |              |      |
                       +--------------+      |
                                             |
                                             |
   |BLUE|                            |GREEN| v
+---------------------------+     +---------------------------+
|   +-------------------+   |     |   +-------------------+   |
|   |Pod_1||Pod_1||Pod_1|   |     |   |Pod_2||Pod_2||Pod_2|   |
|   --------------------+   |     |   --------------------+   |
|                           |     |                           |
|                           |     |                           |
| -------------+  +-------+ |     | -------------+  +-------+ |
| |Deployment_1|  |Replica| |     | |Deployment_2|  |Replica| |
| -------------+  | Set_1 | |     | -------------+  | Set_2 | |
|                 +-------+ |     |                 +-------+ |
+---------------------------+     +---------------------------+
</code></pre>
<ul>
<li>To make our new version of app <strong>V2 Green</strong> live, we will have to point <code>Service</code> to newly created Pod.</li>
<li>For Kubernetes <code>Service</code> we just change the label selector.</li>
</ul>
<h2 id="clean-up-or-roll-back"><a class="header" href="#clean-up-or-roll-back">Clean up or roll back</a></h2>
<ul>
<li>At this stage, we can either cleanup resources or we can roll back to our previous version.</li>
<li>If we think new version of app is stable, we can delete the old Pods / Deployments</li>
<li>But if we need to do a roll back, it is very easy. Just change the Service label selector again.</li>
</ul>
<h2 id="blue-green-deployment-with-kubernetes"><a class="header" href="#blue-green-deployment-with-kubernetes">Blue Green Deployment With Kubernetes</a></h2>
<h3 id="deploy-the-v1-app"><a class="header" href="#deploy-the-v1-app">Deploy the V1 App</a></h3>
<ul>
<li>Create a <code>Deployment</code> with following configuration</li>
</ul>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-v1
  labels:
    version: v1
    env: prod
spec:
  replicas: 3
  selector:
    matchLabels:
      env: prod
      version: v1
  template:
    metadata:
      name: web-v1
      labels:
        version: v1
        env: prod
    spec:
      containers:
        - image: amantuladhar/docker-kubernetes:v1-web
          name: web-v1
          #probes

</code></pre>
<ul>
<li>Notice how I am appending <code>-v1</code> to Deployment, ReplicaSet and Pods name. This is important because we don't want to replace the existing <code>Deployment</code> resource.</li>
</ul>
<h3 id="create-a-service-1"><a class="header" href="#create-a-service-1">Create a Service</a></h3>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: web
spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: 8080
      nodePort: 30000
  selector:
    env: prod
    version: v1
</code></pre>
<ul>
<li>Service at the moment is selecting Pods with <code>version: v1</code> label.</li>
</ul>
<h3 id="update-to-v2-app"><a class="header" href="#update-to-v2-app">Update to V2 App</a></h3>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-v2
  labels:
    version: v2
    env: prod
spec:
  replicas: 3
  selector:
    matchLabels:
      env: prod
      version: v2
  template:
    metadata:
      name: web-v2
      labels:
        version: v2
        env: prod
    spec:
      containers:
        - image: amantuladhar/docker-kubernetes:v2-web
          name: web-v2
          #probes
</code></pre>
<ul>
<li>We create a new <code>Deployment</code> *<strong>-v2.</strong></li>
<li><strong>ReplicaSet / Pods</strong> labels are also suffixed with <strong>-v2</strong></li>
<li>At the moment the Pods created by our new Deployment is not live. Service is still pointing to old version of the app.</li>
<li>After all the new version Pods are ready, we can switch the Service selector.</li>
</ul>
<h3 id="change-the-service-selector"><a class="header" href="#change-the-service-selector">Change the <code>Service</code> selector</a></h3>
<ul>
<li>You can change the Service selector using multiple technique.</li>
<li>I will use <code>kubectl patch</code></li>
</ul>
<pre><code class="language-bash">kubectl patch service web --patch '{&quot;spec&quot;: {&quot;selector&quot;: {&quot;version&quot;: &quot;v2&quot;}}}'
</code></pre>
<ul>
<li>After this you will see all the traffic are now redirected to new version.</li>
</ul>
<h3 id="cleanup--rollback-update"><a class="header" href="#cleanup--rollback-update">Cleanup / Rollback Update</a></h3>
<ul>
<li>If you want to cleanup you can delete the old <code>Deployment</code></li>
<li>If you want to Rollback the update, you can use above command and change selector to <code>v1</code></li>
</ul>
<pre><code class="language-bash">kubectl patch service web --patch '{&quot;spec&quot;: {&quot;selector&quot;: {&quot;version&quot;: &quot;v1&quot;}}}'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variable"><a class="header" href="#environment-variable">Environment Variable</a></h1>
<hr />
<ul>
<li>Most of the apps that we develop nowadays depends on some kind of environment variables / configuration files.</li>
<li>Using configuration files on containers are a bit tricky.</li>
<li>If we push the configuration with container itself, we need to update / build the image every time we change the container.</li>
<li>Often times some configuration properties are secret. We don't want some properties to be passed on carelessly.</li>
<li>Containers normally use environment variables to get configuration.</li>
<li>Kubernetes also supports passing environment variables to <strong>containers</strong>.</li>
</ul>
<blockquote>
<p>Kubernetes doesn't allow Pod level environment. Environment variables are set on container level.</p>
</blockquote>
<ul>
<li>We cannot modify the environment variable for a container once it is set.</li>
<li>We can dispose the current container and re-create a new one.</li>
<li>If you think about the solution above, it make sense right!</li>
<li>Containers are supposed to be immutable, if you change configuration of one container other replicas may not have same configuration.</li>
<li>At least until you make changes to all of them.</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<ul>
<li>Let's create a Deployment that sets environment variable to container.</li>
</ul>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  # metadata
spec:
  # replica &amp; matchLabel selector
  template:
    metadata:
      # metadata
    spec:
      containers:
        - image: amantuladhar/docker-kubernetes:environment   #1
          name: web
          env:                     #2
            - name: GREETING       #3
              value: Namaste       #4
            - name: NAME           #3
              value: Folks!!       #4
          # probe properties
</code></pre>
<ul>
<li><code>#1</code> - We are using new image i.e docker-kubernetes:environment. I have modified the endpoint so that it changes the message based on environment variables.
<ul>
<li><strong>GREETING</strong> - Default is Hello</li>
<li><strong>NAME</strong> - Default is Fellas!!</li>
</ul>
</li>
<li><code>#2</code> - We use <code>env</code> properties to set the environment variable to container.</li>
<li><code>#3</code> - Name of environment variable you want to set</li>
<li><code>#4</code> - Value of environment variable you want to set</li>
</ul>
<h2 id="calling-endpoint"><a class="header" href="#calling-endpoint">Calling Endpoint</a></h2>
<pre><code class="language-bash">➜ http $(minikube service web --url)/test
HTTP/1.1 200
Content-Type: application/json;charset=UTF-8
Date: Tue, 26 Feb 2019 05:47:37 GMT
Transfer-Encoding: chunked

{
    &quot;app.version&quot;: &quot;v1-web&quot;,
    &quot;host.address&quot;: &quot;172.17.0.7&quot;,
    &quot;message&quot;: &quot;Namaste Folks!!&quot;
}
</code></pre>
<h2 id="updating-environment-variable"><a class="header" href="#updating-environment-variable">Updating environment variable</a></h2>
<ul>
<li>Note: To change the environment variable of container, either you need to restart the container</li>
<li>You can update the environment variable easily with command below, but it will restart the container.</li>
</ul>
<pre><code class="language-bash">kubectl set env deployment web GREETING=&quot;Adios&quot;
</code></pre>
<ul>
<li><code>kubectl set env @resource @name @env_var=@env_value</code></li>
<li>If you want to unset environment variable</li>
</ul>
<pre><code class="language-bash">kubectl set env deployment web GREETING-
</code></pre>
<ul>
<li>If you use environment variable and use dash <code>-</code> it will unset the environment variable.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="config-maps"><a class="header" href="#config-maps">Config Maps</a></h1>
<hr />
<ul>
<li>Setting environment variables to container template is one option to send configuration to container.</li>
<li>But if configuration differ from environment to environment like DEV, QA, PROD then setting configuration value on <code>env</code> may not be a good idea.</li>
<li>Kubernetes has a resource called ConfigMaps which treats configuration as a separate object.</li>
<li>So each environment can have same objects, but different values.</li>
</ul>
<h2 id="configmaps-yaml"><a class="header" href="#configmaps-yaml">ConfigMaps YAML</a></h2>
<ul>
<li>Let's create simple ConfigMaps that stores our GREETING and NAME environment variable value.</li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: web
data:
  GREETING: Namaste
  NAME: Friends!!! 
</code></pre>
<ul>
<li>As you can see creating ConfigMap is simple.</li>
<li>You set <code>kind</code> as <code>ConfigMap</code>.</li>
<li>You set name of <code>ConfigMap</code> on <code>metadata</code> section.</li>
<li>On <code>data</code> root node, you add your properties values.</li>
<li>It is just a key value pair.</li>
<li>Here we are setting <strong>GREETING</strong> as Namaste and NAME as Friends!!!</li>
</ul>
<h2 id="creating-configmap"><a class="header" href="#creating-configmap">Creating ConfigMap</a></h2>
<ul>
<li>Creating a <code>ConfigMap</code> is simple too, you just use your handy <code>kubectl create</code> command.</li>
</ul>
<pre><code class="language-bash">kubectl create -f configmap.yaml
</code></pre>
<h2 id="-1"><a class="header" href="#-1"></a></h2>
<p>Using ConfigMap with <code>env</code> property</p>
<ul>
<li>If you want to get specific environment variable value using ConfigMap you can use valueFrom property instead of value property.</li>
</ul>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
# metadata
spec:
  # replicas &amp; selector
  template:
    # metadata
    spec:
      containers:
        - image: amantuladhar/docker-kubernetes:environment
          name: web
          env:
            - name: GREETING
              valueFrom:
                configMapKeyRef:
                  name: web # Name of ConfigMaps
                  key: GREETING
            - name: NAME
              valueFrom:
                configMapKeyRef:
                  name: web # Name of ConfigMaps
                  key: NAME
          # probes &amp; ports
</code></pre>
<ul>
<li>In above file, you can see we are using <code>valueFrom</code> property instead of <code>value</code>.</li>
<li>Using <code>configMapKeyRef</code> tells Kubernetes to search in <code>ConfigMap</code>.</li>
<li><code>configMapKeyRef.name</code> states the name of the <code>ConfigMap</code> resource.</li>
<li><code>configMapKeyRef.key</code> states which key to look for in defined resource.</li>
<li>Run the app using above configuration and call your endpoint</li>
</ul>
<pre><code class="language-bash">➜  http $(minikube service web --url)/test
HTTP/1.1 200
Content-Type: application/json;charset=UTF-8
Date: Wed, 27 Feb 2019 02:00:50 GMT
Transfer-Encoding: chunked

{
    &quot;app.version&quot;: &quot;v1-web&quot;,
    &quot;host.address&quot;: &quot;172.17.0.6&quot;,
    &quot;message&quot;: &quot;Namaste Friends!!!&quot;
}
</code></pre>
<ul>
<li>Now our message has <strong>Namaste Friends!!!.</strong></li>
<li>That's the value we have in our <code>ConfigMaps</code></li>
</ul>
<h2 id="updating-configmap"><a class="header" href="#updating-configmap">Updating ConfigMap</a></h2>
<blockquote>
<p>Note: Updating ConfigMap doesn't update the value a running container has.</p>
<p>If you change value of ConfigMap, two similar container might be in inconsistent state.</p>
</blockquote>
<ul>
<li>You can update the <code>ConfigMap</code> values using <code>kubectl patch</code> command.</li>
</ul>
<pre><code class="language-bash">kubectl patch configmaps web --patch '{&quot;data&quot;: {&quot;GREETING&quot;: &quot;Yo&quot;}}'
</code></pre>
<h2 id="import-all-values-from-configmap"><a class="header" href="#import-all-values-from-configmap">Import All values from ConfigMap</a></h2>
<ul>
<li>While previous method gave us power to pull in value from ConfigMap.</li>
<li>It was troublesome, if we have let's say 20 properties, we have to use <code>valueFrom</code> 20 times.</li>
<li>Kubernetes has another property <code>envFrom</code> which allows you to import all values from <code>ConfigMaps</code></li>
</ul>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
# metadata
spec:
  # replicas &amp; selector
  template:
    # metadata:
    spec:
      containers:
        - image: amantuladhar/docker-kubernetes:environment
          name: web
          envFrom:
            - configMapRef:
                name: web
          # probe and port
</code></pre>
<ul>
<li>In above example, we are using <code>envFrom</code> instead of <code>env</code>.</li>
<li>When we use <code>envFrom</code> property, we import all properties from that resource. (But there is limitation)</li>
<li>We can also use <code>prefix</code> keyword if you want to prefix your configuration properties with something. <code>env.prefix</code></li>
<li>If any of your <code>ConfigMap</code> property has dash <code>-</code>. That won't be imported.</li>
<li>Because environment variable with dash <code>-</code> are invalid.</li>
<li>Kubernetes doesn't do any post-processing for you in this case.</li>
</ul>
<blockquote>
<p>There one more way to load the ConfigMaps i.e. using volumes</p>
<p>We don't know how to mount the volumes yet, so this will be skipped for now.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secrets"><a class="header" href="#secrets">Secrets</a></h1>
<hr />
<ul>
<li>We learned how <code>ConfigMap</code> helps us separate our app template and properties.</li>
<li>While that combination works for almost all scenarios, Kubernetes has one more resources to save the properties i.e <code>Secrets</code></li>
<li><code>Secrets</code> as name suggest should be used to store properties that should be kept secret.</li>
<li>In other words, we should keep the properties in <code>Secret</code> Kubernetes resource.</li>
<li><code>Secrets</code> are more secure and they reduces the risk of accidental exposure.</li>
</ul>
<h2 id="secret-yaml"><a class="header" href="#secret-yaml"><code>Secret</code> YAML</a></h2>
<ul>
<li><code>Secret</code> is not different than ConfigMaps.</li>
<li>Changing the <code>kind</code> from <code>ConfigMap</code> to <code>Secret</code> should do the work. (But there's a catch)</li>
<li>Let's update our previous <code>ConfigMap</code> resource file.</li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: Secret
metadata:
  name: web
data:
  GREETING: Namaste
  NAME: Friends!!!
</code></pre>
<ul>
<li></li>
<li>Let's create this secret and see what happens.</li>
</ul>
<pre><code class="language-bash">kubectl create -f secrets.yaml
</code></pre>
<ul>
<li>You will get an error message that says something like this.</li>
</ul>
<pre><code class="language-bash">Error from server (BadRequest): error when creating &quot;secret-base64.yaml&quot;: 
Secret in version &quot;v1&quot; cannot be handled as a Secret: v1.Secret: 
Data: decode base64: illegal base64 data at input byte 4, error found in #10 byte of ...|:&quot;Namaste&quot;,&quot;NAME&quot;:&quot;F|..., bigger context ...|{&quot;apiVersion&quot;:&quot;v1&quot;,&quot;data&quot;:{&quot;GREETING&quot;:&quot;Namaste&quot;,&quot;NAME&quot;:&quot;Friends!!!&quot;},&quot;kind&quot;:&quot;Secret&quot;,&quot;metadata&quot;:{|...
</code></pre>
<ul>
<li>If you read the error message, you can see Kubernetes is expecting <code>base64</code> value for a configuration data properties. But it is a plain string.</li>
</ul>
<h2 id="secrets-data-are-base64"><a class="header" href="#secrets-data-are-base64"><code>Secrets</code> data are base64</a></h2>
<ul>
<li>Let's convert our data to base64 and add it.</li>
</ul>
<pre><code class="language-bash">➜ echo &quot;Namaste&quot; | base64
TmFtYXN0ZQo=
➜ echo &quot;Friends&quot; | base64
RnJpZW5kcwo=
</code></pre>
<ul>
<li>Our new <code>Secrets</code> definition</li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: Secret
metadata:
  name: web
data:
  GREETING: TmFtYXN0ZQo=
  NAME: RnJpZW5kcwo=
</code></pre>
<ul>
<li>Now let's create a Secret again.</li>
</ul>
<pre><code class="language-bash">kubectl create -f secrets.yaml
</code></pre>
<pre><code class="language-bash">➜  kubectl get secrets web -o yaml
apiVersion: v1
data:
  GREETING: TmFtYXN0ZQo=
  NAME: RnJpZW5kcwo=
kind: Secret
metadata:
  creationTimestamp: &quot;2019-03-02T22:53:07Z&quot;
  name: web
  namespace: default
  resourceVersion: &quot;102112&quot;
  selfLink: /api/v1/namespaces/default/secrets/web
  uid: f1cf2235-3d3d-11e9-aea6-025000000001
type: Opaque
</code></pre>
<h2 id="reading-as-env-var-one-at-a-time"><a class="header" href="#reading-as-env-var-one-at-a-time">Reading as env var one at a time</a></h2>
<ul>
<li>Using Secret is easy as using <code>ConfigMaps</code></li>
<li>Kubernetes when loads the <code>Secrets</code> values to Pods, it doesn't load encrypted value but actual value.</li>
<li>So not conversion is needed.</li>
<li>We use <code>secretKeyRef</code> instead of <code>configMapKeyRef</code>.</li>
</ul>
<pre><code class="language-yaml">env:
  - name: GREETING
    valueFrom:
      secretKeyRef:
        name: web # Name of Secret
        key: GREETING
  - name: NAME
    valueFrom:
      secretKeyRef:
        name: web # Name of Secret
        key: NAME
</code></pre>
<h2 id="reading-all-at-once"><a class="header" href="#reading-all-at-once">Reading all at once</a></h2>
<ul>
<li>Like ConfigMap, instead of <code>configRef</code> instead of <code>secretRef</code>.</li>
</ul>
<pre><code class="language-yaml">envFrom:
  - secretRef:
      name: web 
</code></pre>
<ul>
<li>And that's it, we can access the secrets as environment variable.</li>
</ul>
<h2 id="secret-string-value"><a class="header" href="#secret-string-value"><code>Secret</code> string value</a></h2>
<ul>
<li>As you just saw, even if you want to add a string value to a Secret it's bit hard.</li>
<li>You need to convert your value to base64.</li>
<li>This useful when you load a file on a Secret. (We will get to this when we get to know volume)</li>
<li>But Kubernetes one more property <code>stringData</code>, which let's you add your property value as plain text.</li>
<li>Only thing you need to remember is that <code>stringData</code> property is write only. You cannot read from it. You will know what I mean in a bit.</li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: Secret
metadata:
  name: web
stringData:
  GREETING: Namaste
  NAME: Friends!!!
</code></pre>
<ul>
<li>You can see using <code>stringData</code> we can add secret values as plain text. We can mix and match with <code>data</code> if you want to.</li>
<li>Create a Secrets and see YAML generated by Kubernetes</li>
</ul>
<pre><code class="language-bash">➜  kubectl get secrets web -o yaml
apiVersion: v1
data:
  GREETING: TmFtYXN0ZQ==
  NAME: RnJpZW5kcyEhIQ==
kind: Secret
metadata:
  creationTimestamp: &quot;2019-03-02T23:48:35Z&quot;
  name: web
  namespace: default
  resourceVersion: &quot;105712&quot;
  selfLink: /api/v1/namespaces/default/secrets/web
  uid: b18f158f-3d45-11e9-aea6-025000000001
type: Opaque
</code></pre>
<ul>
<li>Generated YAML doesn't have <code>stringData</code>.</li>
<li>That's why <code>stringData</code> is write only property.</li>
<li>We can write it as plain text in YAML file, but you cannot read it.</li>
<li>When you load a file and create a Secret and Kubernetes will convert the value for you.</li>
</ul>
<blockquote>
<p>Secrets can be mounted as volume. Mostly useful when you load a file on Secrets.</p>
<p>Environment Variables may not be a safest way to expose the Secret values.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="host-path"><a class="header" href="#host-path">Host Path</a></h1>
<hr />
<ul>
<li>We learned how to deploy our Stateless app using Kubernetes.</li>
<li>But we may need to deploy the app that has state, that accesses the database to save the records.</li>
<li>Making a Stateful app run using Kubernetes is a bit tricky, solely because our app can run in different nodes.</li>
<li>Kubernetes out of the box has different types of volumes, but based on cloud provider you use you will have way to save your data.</li>
</ul>
<h2 id="kubernetes-host-path-volume"><a class="header" href="#kubernetes-host-path-volume">Kubernetes Host Path Volume</a></h2>
<ul>
<li>Kubernetes has a simple volume type called hostPath which gives you persistence storage.</li>
<li>But hostPath has one big limitation i.e. hostPath volume mounts a file or directory from the host node’s filesystem into your Pod.</li>
<li>The main point here is that, hostPath volume type mounts the volumes to node.</li>
<li>Our cluster can have multiple nodes, and two nodes doesn't share a filesystem.</li>
<li>Pods with identical configuration may behave differently on different nodes due to different files on the nodes</li>
<li>Because we are developing our app locally we have to use hostPath, and it doesn't affect us. We are running only one node.</li>
</ul>
<h2 id="using-host-path"><a class="header" href="#using-host-path">Using Host Path</a></h2>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
# metadata
spec:
  #replicas &amp; metadata
  template:
    # metadata
    spec:
      volumes:                #1
        - name: volume-name   #2
          hostPath:           #3
            path: /absolute/host/path   #4
      containers:
        - image: amantuladhar/docker-kubernetes:v1-web
          name: web-co
          volumeMounts:                 #5
              - name: volume-name       #6
                mountPath: /containerPath/    #7
</code></pre>
<ul>
<li><code>#1</code>In above Deployment definition, we are using <code>volumes</code> properties to define the volumes we want to use. (This is not a proper way to define volume, but let's go step by step)</li>
<li><code>#2</code> We are giving name to our volume so that we can use it later.</li>
<li><code>#3</code> <code>hostPath</code> property. This is the type of volume we are using. For local development we are using <code>hostPath</code> but this will be provider specific volume type.</li>
<li><code>#4</code> Child property of <code>hostPath</code>. This is an absolute path which points which folder from host to mount.
<ul>
<li>Remember for <code>minikube</code> host path is inside VM.</li>
<li><a href="https://github.com/kubernetes/minikube/blob/master/docs/host_folder_mount.md">Here's a <code>minikube</code> documentation</a> to mount your actual host path to <code>minikube</code> VM, then to mount that volume to Kubernetes.</li>
<li>TLDR; use <code>minikube mount actual/host/path:/minikube/vm/path</code></li>
</ul>
</li>
<li><code>#5</code> Using <code>volumeMounts</code> property we can specify which volumes our container needs to mount.</li>
<li><code>#6</code> Using <code>name</code> property we specify the name of the volume we want to mount.
<ul>
<li>For your purposes it needs to match <code>#2</code></li>
</ul>
</li>
<li><code>#7</code> <code>mountPath</code> take the path inside the container. This is the place where container will access external data.</li>
</ul>
<blockquote>
<p>We are using <code>Deployment</code> here. If you just want to create a <code>Pod</code> you remember, everything below from <code>template</code> property is basically Pod definition.</p>
</blockquote>
<ul>
<li>After you create a resource, we can go inside the Pod and play around with it.</li>
<li>Let's create a file inside the container and see if that file is available on our host.</li>
<li>And let's delete the Pod and see if new Pod can see that file.</li>
</ul>
<pre><code class="language-bash">kubectl create -f hostPath.yaml
</code></pre>
<ul>
<li>Creating file inside Pod</li>
</ul>
<pre><code class="language-bash"># Get inside Pod
➜ kubectl exec -it web-dep-89fd5db9-897dr sh

# Change directory to path where we mounted the volume
/myApp # cd /containerPath/

# Create a file with some text
/containerPath # echo &quot;Very important data&quot; &gt;&gt; file.txt

# Check if file exist (inside container)
/containerPath # ls
file.txt
</code></pre>
<ul>
<li>Check if file is visible in your host path. You will see the file if everything went well.</li>
<li>Now, restart the container and see if file exist.</li>
</ul>
<pre><code class="language-bash">kubectl delete pod --all 
</code></pre>
<ul>
<li>This will delete all the Pods.</li>
<li>But Deployment will spawn new Pod immediately.</li>
<li>Go inside new Pod and see if file exist.</li>
</ul>
<pre><code class="language-bash"># Getting inside new Pod
➜ kubectl exec -it web-dep-89fd5db9-689sw sh

# Checking if file exist
/myApp # ls /containerPath/
file.txt

# Checking the content of file
/myApp # cat /containerPath/file.txt
Very important data
</code></pre>
<ul>
<li>We learned how we can easily mount volume to Kubernetes by using hostPath.</li>
<li>Make sure if you use hostPath on production you know what you are doing.</li>
<li>There may be a scenario where we need this, but for general purposes like database this is not a solution.</li>
<li>Next we will learn how we can improve this example and what problems this solution has.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
